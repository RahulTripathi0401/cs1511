<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />

<title>
    
    COMP1511 20T3 - 
Week 09
Laboratory
Sample Solutions

    
</title><link rel="canonical" href="https://cgi.cse.unsw.edu.au/~cs1511/20T3/" />

<link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/css/bootstrap.min.css"
      integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh" crossorigin="anonymous">
<link rel="stylesheet" href="/~cs1511/20T3/flask.cgi/static/course.css?213751602407825.0" />

<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js"
        integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" crossorigin="anonymous"></script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js" integrity="sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6" crossorigin="anonymous"></script>
<script src="/~cs1511/20T3/flask.cgi/static/course.js?92151599736636.0"></script>


<link rel="icon" type="image/png" href="/~cs1511/20T3/flask.cgi/static/favicon.ico?1271605745352.0">

<!-- <script async src="https://static.codepen.io/assets/embed/ei.js"></script> -->

<!-- MathJax. -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.6/latest.js?config=TeX-MML-AM_CHTML" async="yes"></script>





</head>
<body class="d-flex flex-column" style="min-height: 100vh;">
  <nav class="navbar fixed-top navbar-expand-lg navbar-light no-print" id="header-navbar">
  <div class="container">
    <button class="navbar-toggler navbar-toggler-right"
            type="button" data-toggle="collapse" data-target="#navmenu"
            aria-controls="navmenu" aria-label="Toggle navigation" aria-expanded="false">
      <span class="navbar-toggler-icon"></span>
    </button>

    <a class="navbar-brand" href="https://cgi.cse.unsw.edu.au/~cs1511/20T3/">
      COMP1511 20T3
    </a>

    <div class="collapse navbar-collapse" id="navmenu">
      <ul class="navbar-nav mr-auto">
        <li class="nav-item active"><a class="nav-link" href="https://discourse.cse.unsw.edu.au/20t3/comp1511/">Forum</a></li>
        <li class="nav-item active"><a class="nav-link" href="https://cgi.cse.unsw.edu.au/~cs1511/20T3/student/">Submissions</a></li>

        
        <li class="nav-item active"><a class="nav-link" href="https://cgi.cse.unsw.edu.au/~cs1511/20T3/assignments/ass1/index.html">Assignment 1</a></li>
        

        
        <li class="nav-item active"><a class="nav-link" href="https://cgi.cse.unsw.edu.au/~cs1511/20T3/assignments/ass2/index.html">Assignment 2</a></li>
        

        <li class="navbar-text px-2">|</li>
        


    
        
        
        
        
    

    
        
        
        
        
    

    
        
        
        
        
    

    
        
        
        
        
    

    
        
        
        
        
    

    
        
        
        
        
    

    
        
        
        
        
    

    
        
        
        
        
    

    
        
        
        
        
    

    
        
        
        
        
    

    


<li class="nav-item active dropdown">
  <a role="button" class="nav-link dropdown-toggle" id="week-selector"
     href="#" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
    Week 09 <span class="caret"></span>
  </a>
  <div class="dropdown-menu" aria-labelledby="week-selector">
  
    <a class="dropdown-item" href="https://cgi.cse.unsw.edu.au/~cs1511/20T3/lab/01/answers">Week 01</a>
    <a class="dropdown-item" href="https://cgi.cse.unsw.edu.au/~cs1511/20T3/lab/02/answers">Week 02</a>
    <a class="dropdown-item" href="https://cgi.cse.unsw.edu.au/~cs1511/20T3/lab/03/answers">Week 03</a>
    <a class="dropdown-item" href="https://cgi.cse.unsw.edu.au/~cs1511/20T3/lab/04/answers">Week 04</a>
    <a class="dropdown-item" href="https://cgi.cse.unsw.edu.au/~cs1511/20T3/lab/05/answers">Week 05</a>
    <a class="dropdown-item" href="https://cgi.cse.unsw.edu.au/~cs1511/20T3/lab/06/answers">Week 06</a>
    <a class="dropdown-item" href="https://cgi.cse.unsw.edu.au/~cs1511/20T3/lab/07/answers">Week 07</a>
    <a class="dropdown-item" href="https://cgi.cse.unsw.edu.au/~cs1511/20T3/lab/08/answers">Week 08</a>
    <a class="dropdown-item" href="https://cgi.cse.unsw.edu.au/~cs1511/20T3/lab/09/answers">Week 09</a>
    <a class="dropdown-item" href="https://cgi.cse.unsw.edu.au/~cs1511/20T3/lab/10/answers">Week 10</a>
  </div>
</li>



    
        
        
        
        
    

    
        
        
        
        
    

    
        
        
        
        
    


<li class="nav-item active dropdown">
  <a role="button" class="nav-link dropdown-toggle" id="tlb-selector"
     href="#" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
    Laboratory <span class="caret"></span>
  </a>
  <div class="dropdown-menu" aria-labelledby="tlb-selector">
  
    <a class="dropdown-item" href="https://cgi.cse.unsw.edu.au/~cs1511/20T3/tut/09/answers">Tutorial</a>
    <a class="dropdown-item" href="https://cgi.cse.unsw.edu.au/~cs1511/20T3/lab/09/answers">Laboratory</a>
    <a class="dropdown-item" href="https://cgi.cse.unsw.edu.au/~cs1511/20T3/test/09/answers">Weekly Test</a>
  </div>
</li>



    
    
    
    

    
    
    
    



<li class="nav-item active dropdown">
  <a role="button" class="nav-link dropdown-toggle" id="qa-selector"
     href="#" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
    Sample Solutions <span class="caret"></span>
  </a>
  <div class="dropdown-menu" aria-labelledby="qa-selector">
  
    <a class="dropdown-item" href="https://cgi.cse.unsw.edu.au/~cs1511/20T3/lab/09/questions">Exercises</a>
    <a class="dropdown-item" href="https://cgi.cse.unsw.edu.au/~cs1511/20T3/lab/09/answers">Sample Solutions</a>
  </div>
</li>


      </ul>
    </div>
  </div>
</nav>


<main class="container" aria-label="Content" style="flex: 1; padding-top: 4rem;">


<header>

<h1 class="text-center">
Week 09
Laboratory
Sample Solutions
</h1>

</header>


<div class="tutlab lab">




<section class="exercise ">
    <header><h3>Objectives</h3></header>
    

<ul>

<li>More complex linked lists</li>

<li>Practice working with lists of lists</li>

</ul>


    </section>



<section class="exercise ">
    <header><h3>Preparation</h3></header>
    


<p>
Before the lab you should re-read the relevant lecture slides and their accompanying examples.



    </section>









 






    


<section class="exercise with-pair">
    <header><h3><small style="font-variant: small-caps; text-transform: lowercase;">Exercise — in pairs:
    </small><br />Check whether a Linked List is in Increasing Order</h3></header>
    











<p>
Download list_increasing.c <a href="https://cgi.cse.unsw.edu.au/~cs1511/20T3/activities/list_increasing/list_increasing.c">here</a>, or copy it to your CSE
account using the following command:

<pre is="tty">
<kbd is="sh">cp -n /web/cs1511/20T3/activities/list_increasing/list_increasing.c .</kbd>
</pre>




<p>
Your task is to add code to this function in <b>list_increasing.c</b>:


<div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">increasing</span><span class="p">(</span><span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">head</span><span class="p">)</span> <span class="p">{</span>

    <span class="c1">// PUT YOUR CODE HERE (change the next line!)</span>
    <span class="k">return</span> <span class="mi">42</span><span class="p">;</span>

<span class="p">}</span>
</pre></div>





<b>increasing</b> is given  one argument, <b>head</b>, which is the pointer to the first node in a linked list.
<p>
Add code to <b>increasing</b> so that its returns 1 if the list is in increasing order - the value of each list element is larger than the element before.
<p>
For example if the linked list contains these 8 elements:
<p>
<pre>
1, 7, 8, 9, 13, 19, 21, 42
</pre>
<p>
<b>increasing</b> should return <b>1</b> because  is is increasing order

<h4>Testing</h4>

<b>list_increasing.c</b> also contains a <b>main</b> function which allows you to test your <b>increasing</b> function.
<p>
This main function:
<ul>
<li> converts the command-line arguments to a linked list
<li> assigns a pointer to the first node in the linked list to <b>head</b>
<li> calls <b>list_increasing(head)</b>
<li> prints the result.
</ul>
<p>
<p>
Do not change this main function.  If you want to change it, you have misread the question.
<p>
Your <b>list_increasing</b> function will be called directly in marking.  The main function is only to let you test your <b>list_increasing</b> function
<p>
Here is how you use main function allows you to test <b>list_increasing</b>:
<p>

<pre is="tty">
<kbd is="sh">dcc list_increasing.c -o list_increasing</kbd>
<kbd is="sh">./list_increasing 1 2 4 8 16 32 64 128 256</kbd>
1
<kbd is="sh">./list_increasing 2 4 6 5 8 9</kbd>
0
<kbd is="sh">./list_increasing 13 15 17 17 18 19</kbd>
0
<kbd is="sh">./list_increasing 2 4</kbd>
1
<kbd is="sh">./list_increasing 42</kbd>
1
<kbd is="sh">./list_increasing</kbd>
1
</pre>




<h4>Assumptions/Restrictions/Clarifications.</h4>

<b>increasing</b> should return a single integer.
<p>
<b>increasing</b> should not change the linked list it is given.
Your function should not change the next or data fields of list nodes.
<p>
<b>increasing</b> should not use arrays.
<p>
<b>increasing</b> should not call malloc.
<p>
<b>increasing</b> should not call scanf (or getchar or fgets).
<p>
You can assume the linked list only contains positive integers.
<p>
<b>increasing</b> should not print anything. It should not call printf.
<p>
Do not change the supplied <b>main</b> function. It will not be tested or marked.









<div class="alert alert-info">
<strong>New!</strong>
You can run an automated code style checker using the following command:

<pre is="tty">
<kbd is="sh">1511 style list_increasing.c</kbd>
</pre>
</div>




<p>
When you think your program is working,
you can use <code>autotest</code>
to run some simple automated tests:

<pre is="tty">
<kbd is="sh">1511 autotest list_increasing</kbd>
</pre>
















<p>
When you are finished working on this exercise,

you and your lab partner must both

submit your work by running <code>give</code>:

<pre is="tty">
<kbd is="sh">give cs1511 lab09_list_increasing list_increasing.c</kbd>
</pre>

<p>

Note, even though this is a pair exercise,
you both must run <code>give</code> from your own account

before <strong>Sunday 15 November 20:00</strong>
to obtain the marks for this lab exercise.






    
        
        
            
            <div class="answer">
                Sample solution for <code>list_increasing.c</code>
                
<div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;assert.h&gt;</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">node</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
    <span class="kt">int</span>          <span class="n">data</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">increasing</span><span class="p">(</span><span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">head</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="nf">strings_to_list</span><span class="p">(</span><span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">strings</span><span class="p">[]);</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="c1">// create linked list from command line arguments</span>
    <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">head</span> <span class="o">=</span> <span class="n">strings_to_list</span><span class="p">(</span><span class="n">argc</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>

    <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">increasing</span><span class="p">(</span><span class="n">head</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// return 1 if values in a linked list are in increasing order,</span>
<span class="c1">// return 0, otherwise</span>

<span class="kt">int</span> <span class="nf">increasing</span><span class="p">(</span><span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">head</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// If the list is empty, it&#39;s considered increasing, so return 1.</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">head</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// Assume that it is increasing, and look for evidence</span>
    <span class="c1">// that proves otherwise.</span>
    <span class="kt">int</span> <span class="n">is_increasing</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

    <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">curr</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// If this one is not less than the next one,</span>
        <span class="c1">// the list definitely isn&#39;t increasing</span>
        <span class="c1">// (since these two nodes are out of order).</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">&gt;=</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">)</span>  <span class="p">{</span>
            <span class="n">is_increasing</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">curr</span> <span class="o">=</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// At this point, if is_increasing is still 1, we didn&#39;t find</span>
    <span class="c1">// any nodes that were out of order.</span>
    <span class="c1">//</span>
    <span class="c1">// However, if we did find any nodes that were out of order,</span>
    <span class="c1">// we set it to 0 in the loop above.</span>
    <span class="c1">//</span>
    <span class="c1">// So, is_increasing contains the answer to return.</span>
    <span class="k">return</span> <span class="n">is_increasing</span><span class="p">;</span>
<span class="p">}</span>


<span class="c1">// create linked list from array of strings</span>
<span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="nf">strings_to_list</span><span class="p">(</span><span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">strings</span><span class="p">[])</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">head</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">n</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span> <span class="p">(</span><span class="k">struct</span> <span class="n">node</span><span class="p">));</span>
        <span class="n">assert</span><span class="p">(</span><span class="n">n</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
        <span class="n">n</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
        <span class="n">n</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">atoi</span><span class="p">(</span><span class="n">strings</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="n">head</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">head</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


                
                    Alternative solution for <code>list_increasing.c</code>
                    
<div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;assert.h&gt;</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">node</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
    <span class="kt">int</span>          <span class="n">data</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">increasing</span><span class="p">(</span><span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">head</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="nf">strings_to_list</span><span class="p">(</span><span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">strings</span><span class="p">[]);</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="c1">// create linked list from command line arguments</span>
    <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">head</span> <span class="o">=</span> <span class="n">strings_to_list</span><span class="p">(</span><span class="n">argc</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>

    <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">increasing</span><span class="p">(</span><span class="n">head</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// return 1 if values in a linked list are in increasing order,</span>
<span class="c1">// return 0, otherwise</span>

<span class="kt">int</span> <span class="nf">increasing</span><span class="p">(</span><span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">head</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">head</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">&gt;=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">)</span>  <span class="p">{</span>
            <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>


<span class="c1">// create linked list from array of strings</span>
<span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="nf">strings_to_list</span><span class="p">(</span><span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">strings</span><span class="p">[])</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">head</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">n</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span> <span class="p">(</span><span class="k">struct</span> <span class="n">node</span><span class="p">));</span>
        <span class="n">assert</span><span class="p">(</span><span class="n">n</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
        <span class="n">n</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
        <span class="n">n</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">atoi</span><span class="p">(</span><span class="n">strings</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="n">head</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">head</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>

                
                    Alternative solution for <code>list_increasing.c</code>
                    
<div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;assert.h&gt;</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">node</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
    <span class="kt">int</span>          <span class="n">data</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// return 1 if values in a linked list in increasing order</span>
<span class="c1">// recursive solution</span>

<span class="kt">int</span> <span class="nf">increasing</span><span class="p">(</span><span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">head</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">head</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">&gt;=</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">)</span>  <span class="p">{</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">increasing</span><span class="p">(</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>

                
            </div>
            
        
    



    </section>

 






    


<section class="exercise with-pair">
    <header><h3><small style="font-variant: small-caps; text-transform: lowercase;">Exercise — in pairs:
    </small><br />Write tests using capture.c for list_print</h3></header>
    










<p>This exercise is about writing code to test other code, rather than the usual code that performs
a specific task. You will also be using a multi-file project, including <code>list.c</code> and 
<code>list.h</code>, that have some simple functions to create and print out a linked list. We have 
provided an example <code>list.c</code> and <code>list.h</code>, but your code will be tested
against a different list.c that may not be implemented correctly.</p>

<p>Inside <code>list.c</code> there are two functions that you will use. The first function is <code>nums_to_list</code>
  which takes a <code>length</code>, and an array of integers. It returns a linked list of integers, of length <code>length</code>.
  This function will always work correctly. The second function is <code>print_list</code>, which takes a linked list as it's argument.
  This function will be broken during testing; and it your job to check it works correctly. The function prints out empty lists as <code>X</code>.
  Lists with elements in them are printed like this: <code>1 -> 2 -> X</code>.

<p>Your task is to edit <code>list_print_test.c</code> so that it will test whether the function 
  <code>print_list</code> in <code>list.c</code> is working correctly.
  You will write code to perform these tests in each of the empty functions in 
  <code>list_print_test.c</code>.
  Each of these functions will need to use the provided <code>CAPTURE</code> macro; and will also
  probably use the provided <code>string_contains</code> function.</p>

<ul>
  <li>
    <code>void test_print_empty_list(void);</code> is an example of what your code should do.
    <strong>You do not need to modify this code.</strong>
  </li>
  <li>
    <code>void test_print_one_elem_list(void);</code> should test whether a list with one element
    is printed out correctly.
  </li>
  <li>
    <code>void test_print_repeated_elem_list(void);</code> should test whether a list with two
    adjacent elements of the same value is printed out correctly. That is, if you printed out
    the list <code>1 -> 1 -> X</code>, would it print the correct result.
  </li>
  <li>
    <code>void test_print_ten_elem_list(void);</code> should test whether a list with ten or more
    elements is printed out correctly.
  </li>

</ul>

<div class="alert alert-secondary">
<a href="https://cgi.cse.unsw.edu.au/~cs1511/20T3/activities/list_print_test/list_print_test.zip">
<strong>Download the starter code (list_print_test.zip) here</strong>
</a>
or copy it to your CSE account using the following command:
<pre is="tty">
<kbd is="sh">1511 setup_list_print_test</kbd>
</pre>
</div>
<br/>

<p>In this activity, there are 5 files you will be using:

  <p>

<a href="https://cgi.cse.unsw.edu.au/~cs1511/20T3/activities/list_print_test/list_print_test.c"><code class="lang-clike">list_print_test.c</code></a>
This file contains the main function, and all the tests. It is <strong>the only file you will need to change in this activity</strong>

<p>
  <a href="https://cgi.cse.unsw.edu.au/~cs1511/20T3/activities/list_print_test/list.h"><code class="lang-clike">list.h</code></a> contains the definitions of all the list
  related functions in this activity.
<strong>You must not change this file.</strong>

<p>
<a href="https://cgi.cse.unsw.edu.au/~cs1511/20T3/activities/list_print_test/list.c"><code class="lang-clike">list.c</code></a> contains the implementation of some simple list-related functions.
<strong>You must not change this file.</strong>

<p>
    <a href="https://cgi.cse.unsw.edu.au/~cs1511/20T3/activities/list_print_test/capture.h"><code class="lang-clike">capture.h</code></a> contains the definition of a function that allows you to capture the output of your own code, to use in testing. It can only be used in <code>list_print_test.c</code>.
    <strong>You must not change this file.</strong>
  <p>
    <a href="https://cgi.cse.unsw.edu.au/~cs1511/20T3/activities/list_print_test/capture.c"><code class="lang-clike">capture.c</code></a> contains the implementation of functions that allow you to capture the output of your own code, to use in testing. 
    <strong>You must not change this file.</strong>
<p>

<h4>Autotests</h4>
<p>For this exercise, the autotests will take your <code>list_print_test.c</code> file and compile it with multiple broken solutions; to test how it works. The
  simplest way to test this activity is to use the autotest command. If, however, you wish to have access to these broken solutions directly, you should use the
  <code>1511 list_print_test_compile</code> command. This command has four modes:
  <ul>
    <li><code>1511 list_print_test_compile normal list_print_test.c</code> will compile your tests against a valid solution.</li>
    <li><code>1511 list_print_test_compile one list_print_test.c</code> will compile your tests against a solution that doesn't work when the list contains a single element.</li>
    <li><code>1511 list_print_test_compile rpt list_print_test.c</code> will compile your tests against a solution that doesn't work when the list contains a repeated element.</li>
    <li><code>1511 list_print_test_compile many list_print_test.c</code> will compile your tests against a solution that doesn't work when the list contains ten or more elements.</li>
  </ul>
  <p>In each case, the command will create an executable called <code>list_print_test</code>.</p>

<h4>Assumptions/Restrictions/Clarifications.</h4>
<p>
<ul>
  <li>You don't need to test every valid input -- only testing one or two will be enough.
  <li>The provided <code>list.c</code> is an example only. Your code will be tested against possibly
      mulitple versions of <code>list.c</code> that are functioning incorrectly in different ways.
  <li>Specific instructions for what each of the tests should be testing for is in the comments of 
      <code>list_print_test.c</code>
</ul>
</p>









<div class="alert alert-info">
<strong>New!</strong>
You can run an automated code style checker using the following command:

<pre is="tty">
<kbd is="sh">1511 style list_print_test.c</kbd>
</pre>
</div>




<p>
When you think your program is working,
you can use <code>autotest</code>
to run some simple automated tests:

<pre is="tty">
<kbd is="sh">1511 autotest list_print_test</kbd>
</pre>
















<p>
When you are finished working on this exercise,

you and your lab partner must both

submit your work by running <code>give</code>:

<pre is="tty">
<kbd is="sh">give cs1511 lab09_list_print_test list_print_test.c</kbd>
</pre>

<p>

Note, even though this is a pair exercise,
you both must run <code>give</code> from your own account

before <strong>Sunday 15 November 20:00</strong>
to obtain the marks for this lab exercise.






    
        
        
            
            <div class="answer">
                Sample solution for <code>list_print_test.c</code>
                
<div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&quot;list.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;capture.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp"></span>

<span class="cp">#define SIZE 10</span>
<span class="cp">#define MAX_PRINT 10000</span>

<span class="kt">int</span> <span class="nf">string_contains</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">haystack</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">needle</span><span class="p">);</span>

<span class="c1">// Test whether print_list works for empty lists.</span>
<span class="kt">void</span> <span class="nf">test_print_empty_list</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Test printing out an empty list: &quot;</span><span class="p">);</span>

    <span class="kt">int</span> <span class="n">num_array</span><span class="p">[</span><span class="n">SIZE</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">};</span>
    <span class="n">List</span> <span class="n">l</span> <span class="o">=</span> <span class="n">nums_to_list</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">num_array</span><span class="p">);</span>
    <span class="kt">char</span> <span class="n">str</span><span class="p">[</span><span class="n">MAX_PRINT</span><span class="p">];</span>
    <span class="n">CAPTURE</span><span class="p">(</span><span class="n">print_list</span><span class="p">(</span><span class="n">l</span><span class="p">),</span> <span class="n">str</span><span class="p">,</span> <span class="n">MAX_PRINT</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">string_contains</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="s">&quot;X&quot;</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;DOES NOT MEET SPEC</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;MEETS SPEC</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// Test whether print_list works for lists of length 1.</span>
<span class="kt">void</span> <span class="nf">test_print_one_elem_list</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Test printing out a list with one element: &quot;</span><span class="p">);</span>

    <span class="kt">int</span> <span class="n">num_array</span><span class="p">[</span><span class="n">SIZE</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">};</span>
    <span class="n">List</span> <span class="n">l</span> <span class="o">=</span> <span class="n">nums_to_list</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_array</span><span class="p">);</span>
    <span class="kt">char</span> <span class="n">str</span><span class="p">[</span><span class="n">MAX_PRINT</span><span class="p">];</span>
    <span class="n">CAPTURE</span><span class="p">(</span><span class="n">print_list</span><span class="p">(</span><span class="n">l</span><span class="p">),</span> <span class="n">str</span><span class="p">,</span> <span class="n">MAX_PRINT</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">string_contains</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="s">&quot;1 -&gt; X&quot;</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;DOES NOT MEET SPEC</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;MEETS SPEC</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// Test whether print_list works for lists with the same element twice.</span>
<span class="kt">void</span> <span class="nf">test_print_repeated_elem_list</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Test printing out a list with a repeated element: &quot;</span><span class="p">);</span>

    <span class="kt">int</span> <span class="n">num_array</span><span class="p">[</span><span class="n">SIZE</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">};</span>
    <span class="n">List</span> <span class="n">l</span> <span class="o">=</span> <span class="n">nums_to_list</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">num_array</span><span class="p">);</span>
    <span class="kt">char</span> <span class="n">str</span><span class="p">[</span><span class="n">MAX_PRINT</span><span class="p">];</span>
    <span class="n">CAPTURE</span><span class="p">(</span><span class="n">print_list</span><span class="p">(</span><span class="n">l</span><span class="p">),</span> <span class="n">str</span><span class="p">,</span> <span class="n">MAX_PRINT</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">string_contains</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="s">&quot;1 -&gt; 1 -&gt; 2 -&gt; 2 -&gt; X&quot;</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;DOES NOT MEET SPEC</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;MEETS SPEC</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// Test whether print_list works for lists with more than ten elements.</span>
<span class="kt">void</span> <span class="nf">test_print_ten_elem_list</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Test printing out a list with ten elements: &quot;</span><span class="p">);</span>

    <span class="kt">int</span> <span class="n">num_array</span><span class="p">[</span><span class="n">SIZE</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">};</span>
    <span class="n">List</span> <span class="n">l</span> <span class="o">=</span> <span class="n">nums_to_list</span><span class="p">(</span><span class="n">SIZE</span><span class="p">,</span> <span class="n">num_array</span><span class="p">);</span>
    <span class="kt">char</span> <span class="n">str</span><span class="p">[</span><span class="n">MAX_PRINT</span><span class="p">];</span>
    <span class="n">CAPTURE</span><span class="p">(</span><span class="n">print_list</span><span class="p">(</span><span class="n">l</span><span class="p">),</span> <span class="n">str</span><span class="p">,</span> <span class="n">MAX_PRINT</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">string_contains</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="s">&quot;1 -&gt; 3 -&gt; 2 -&gt; 4 -&gt; 5 -&gt; 6 -&gt; 7 -&gt; 8 -&gt; 9 -&gt; 10 -&gt; X&quot;</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;DOES NOT MEET SPEC</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;MEETS SPEC</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">//////////////////////////////////////////////////////////////////////////</span>
<span class="c1">// NOTE: DO NOT EDIT BELOW THIS COMMENT!                                //</span>
<span class="c1">//////////////////////////////////////////////////////////////////////////</span>

<span class="c1">// Find the string &#39;needle&#39; in &#39;haystack&#39;</span>
<span class="kt">int</span> <span class="nf">string_contains</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">haystack</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">needle</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">strstr</span><span class="p">(</span><span class="n">haystack</span><span class="p">,</span> <span class="n">needle</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">test_print_empty_list</span><span class="p">();</span>
    <span class="n">test_print_one_elem_list</span><span class="p">();</span>
    <span class="n">test_print_repeated_elem_list</span><span class="p">();</span>
    <span class="n">test_print_ten_elem_list</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>


                
            </div>
            
        
    



    </section>

 






    


<section class="exercise with-pair">
    <header><h3><small style="font-variant: small-caps; text-transform: lowercase;">Exercise — in pairs:
    </small><br />Delete First Element from a Linked List</h3></header>
    











<p>
Download list_delete_first.c <a href="https://cgi.cse.unsw.edu.au/~cs1511/20T3/activities/list_delete_first/list_delete_first.c">here</a>, or copy it to your CSE
account using the following command:

<pre is="tty">
<kbd is="sh">cp -n /web/cs1511/20T3/activities/list_delete_first/list_delete_first.c .</kbd>
</pre>




<p>
Your task is to add code to this function in <b>list_delete_first.c</b>:


<div class="highlight"><pre><span></span><span class="c1">//</span>
<span class="c1">// Delete the first node in list.</span>
<span class="c1">// The deleted node is freed.</span>
<span class="c1">// The head of the list is returned.</span>
<span class="c1">//</span>
<span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="nf">delete_first</span><span class="p">(</span><span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">head</span><span class="p">)</span> <span class="p">{</span>

    <span class="c1">// PUT YOUR CODE HERE (change the next line!)</span>
    <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>





Note <b>list_delete_first.c</b> uses the following familiar data type:

<pre class="program">
struct node {
    struct node *next;
    int          data;
};
</pre>


<b>delete_first</b> is given  one argument, <b>head</b>, which is the pointer to the first node in the linked list.
<p>
Add code to <b>delete_first</b> so that it deletes the first node from list.
<p>
<b>delete_first</b> should return a pointer to the new first node in the list.
<p>
If the list is now empty <b>delete_first</b> should return <b>NULL</b>.
<p>
<b>delete_first</b> should call <b>free</b> to free the memory of the node it deletes.
<p>
For example if the linked list contains these 8 elements:
<p>
<pre>
16, 7, 8, 12, 13, 19, 21, 12
</pre>
<p>
<b>delete_first</b> should return a pointer to a list with these elements:
<p>
<pre>
7, 8, 12, 13, 19, 21, 12
</pre>
<p>
<b>Hint</b>: this is a simple task requiring only a few lines of code.

<h4>Testing</h4>

<b>list_delete_first.c</b> also contains a <b>main</b> function which allows you to test your <b>delete_first</b> function.
It converts command-line arguments to a linked list, calls <b>delete_first</b>, and then prints the result.
<p>
Do not change this main function.  If you want to change it, you have misread the question.
<p>
Your <b>delete_first</b> function will be called directly in marking.  The main function is only to let you test your <b>delete_first</b> function
<p>
Here is how you the main function allows you to test <b>delete_first</b>:
<p>

<pre is="tty">
<kbd is="sh">cp -n /web/cs1511/20T3/activities/list_delete_first/list_delete_first.c .</kbd>
<kbd is="sh">dcc list_delete_first.c -o list_delete_first</kbd>
<kbd is="sh">./list_delete_first 16 7 8 12 13 19 21 12</kbd>
[7, 8, 12, 13, 19, 21, 12]
<kbd is="sh">./list_delete_first 2 4 6 2 4 6</kbd>
[4, 6, 2, 4, 6]
<kbd is="sh">./list_delete_first 42</kbd>
[]
<kbd is="sh">./list_delete_first</kbd>
[]
</pre>




<h4>Assumptions/Restrictions/Clarifications.</h4>

<b>delete_first</b> should call <b>free</b> to free the memory for the node it deletes
<p>
<b>delete_first</b> should not change the data fields of list nodes.
<p>
<b>delete_first</b> should not use arrays.
<p>
<b>delete_first</b> should not call malloc.
<p>
<b>delete_first</b> should not call scanf (or getchar or fgets).
<p>
<b>delete_first</b> should not print anything. It should not call printf.
<p>
Do not change the supplied <b>main</b> function. It will not be tested or marked.









<div class="alert alert-info">
<strong>New!</strong>
You can run an automated code style checker using the following command:

<pre is="tty">
<kbd is="sh">1511 style list_delete_first.c</kbd>
</pre>
</div>




<p>
When you think your program is working,
you can use <code>autotest</code>
to run some simple automated tests:

<pre is="tty">
<kbd is="sh">1511 autotest list_delete_first</kbd>
</pre>
















<p>
When you are finished working on this exercise,

you and your lab partner must both

submit your work by running <code>give</code>:

<pre is="tty">
<kbd is="sh">give cs1511 lab09_list_delete_first list_delete_first.c</kbd>
</pre>

<p>

Note, even though this is a pair exercise,
you both must run <code>give</code> from your own account

before <strong>Sunday 15 November 20:00</strong>
to obtain the marks for this lab exercise.






    
        
        
            
            <div class="answer">
                Sample solution for <code>list_delete_first.c</code>
                
<div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;assert.h&gt;</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">node</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
    <span class="kt">int</span>          <span class="n">data</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="nf">delete_first</span><span class="p">(</span><span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">head</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="nf">strings_to_list</span><span class="p">(</span><span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">strings</span><span class="p">[]);</span>
<span class="kt">void</span> <span class="nf">print_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">head</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="c1">// create linked list from command line arguments</span>
    <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">head</span> <span class="o">=</span> <span class="n">strings_to_list</span><span class="p">(</span><span class="n">argc</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>

    <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">new_head</span> <span class="o">=</span> <span class="n">delete_first</span><span class="p">(</span><span class="n">head</span><span class="p">);</span>
    <span class="n">print_list</span><span class="p">(</span><span class="n">new_head</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Delete the first node in list.</span>
<span class="c1">// The deleted node is freed.</span>
<span class="c1">// The head of the list is returned.</span>

<span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="nf">delete_first</span><span class="p">(</span><span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">head</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">head</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// list is empty no node to delete</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">new_head</span> <span class="o">=</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="n">free</span><span class="p">(</span><span class="n">head</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">new_head</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// create linked list from array of strings</span>
<span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="nf">strings_to_list</span><span class="p">(</span><span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">strings</span><span class="p">[])</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">head</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">n</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span> <span class="p">(</span><span class="k">struct</span> <span class="n">node</span><span class="p">));</span>
        <span class="n">assert</span><span class="p">(</span><span class="n">n</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
        <span class="n">n</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
        <span class="n">n</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">atoi</span><span class="p">(</span><span class="n">strings</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="n">head</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">head</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// print linked list</span>
<span class="kt">void</span> <span class="nf">print_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">head</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;[&quot;</span><span class="p">);</span>

    <span class="k">for</span> <span class="p">(</span><span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">n</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span> <span class="n">n</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="n">n</span> <span class="o">=</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// If you&#39;re getting an error here,</span>
        <span class="c1">// you have returned an invalid list</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">&quot;, &quot;</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


                
            </div>
            
        
    



    </section>

 






    


<section class="exercise with-pair">
    <header><h3><small style="font-variant: small-caps; text-transform: lowercase;">Exercise — in pairs:
    </small><br />Delete First Element Containing A Value from a Linked List</h3></header>
    











<p>
Download list_delete_contains.c <a href="https://cgi.cse.unsw.edu.au/~cs1511/20T3/activities/list_delete_contains/list_delete_contains.c">here</a>, or copy it to your CSE
account using the following command:

<pre is="tty">
<kbd is="sh">cp -n /web/cs1511/20T3/activities/list_delete_contains/list_delete_contains.c .</kbd>
</pre>




<p>
Your task is to add code to this function in <b>list_delete_contains.c</b>:


<div class="highlight"><pre><span></span><span class="c1">//</span>
<span class="c1">// Delete the first node in the list containing the value `value`.</span>
<span class="c1">// The deleted node is freed.</span>
<span class="c1">// If no node contains `value`, the list is not changed.</span>
<span class="c1">// The head of the list is returned.</span>
<span class="c1">//</span>
<span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="nf">delete_contains</span><span class="p">(</span><span class="kt">int</span> <span class="n">value</span><span class="p">,</span> <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">head</span><span class="p">)</span> <span class="p">{</span>

    <span class="c1">// PUT YOUR CODE HERE (change the next line!)</span>
    <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

<span class="p">}</span>
</pre></div>





Note <b>list_delete_contains.c</b> uses the following familiar data type:

<pre class="program">
struct node {
    struct node *next;
    int          data;
};
</pre>


<b>delete_contains</b> is given  two argument, <b>value</b> and <b>head</b>.
<b>value</b> is an int.
<b>head</b> is the pointer to the first node in a linked list.
<p>
Add code to <b>delete_contains</b> so that it deletes the first node in the linked list
that whose <i>data</i> field equals <b>value</b>.
<p>
If <b>value</b> does not occur in the linked list, the list should not be changed.
<p>
If <b>value</b> occurs more than once in the linked list, only the first occurrence should be deleted.
<p>
<b>delete_contains</b> should return a pointer to the new list.
<p>
If the list is now empty <b>delete_contains</b> should return <b>NULL</b>.
<p>
<b>delete_contains</b> should call <b>free</b> to free the memory of the node it deletes.
<p>
For example if <b>value</b> is <b>12</b> and the linked list contains these 8 elements:
<p>
<pre>
16, 7, 8, 12, 13, 19, 21, 12
</pre>
<p>
<b>delete_contains</b> should return a pointer to a list with these elements:
<p>
<pre>
16, 7, 8, 13, 19, 21, 12
</pre>

<h4>Testing</h4>

<b>list_delete_contains.c</b> also contains a <b>main</b> function which allows you to test your <b>delete_contains</b> function.
<p>
This main function:
<ul>
<li> converts the command-line arguments to a linked list
<li> assigns a pointer to the first node in the linked list to <b>head</b>
<li> reads a single integer from standard input and assigns it to <b>value</b>
<li> calls <b>delete_contains(value, head)</b>
<li> prints the result.
</ul>
<p>
Do not change this main function.  If you want to change it, you have misread the question.
<p>
Your <b>delete_contains</b> function will be called directly in marking.  The main function is only to let you test your <b>delete_contains</b> function
<p>

<pre is="tty">
<kbd is="sh">cp -n /web/cs1511/20T3/activities/list_delete_contains/list_delete_contains.c .</kbd>
<kbd is="sh">dcc list_delete_contains.c -o list_delete_contains</kbd>
<kbd is="sh">./list_delete_contains 16 7 8 12 13 19 21 12</kbd>
<kbd>12</kbd>
[16, 7, 8, 13, 19, 21, 12]
<kbd is="sh">./list_delete_contains 16 7 8 12 13 19 21 12</kbd>
<kbd>42</kbd>
[16, 7, 8, 12, 13, 19, 21, 12]
<kbd is="sh">./list_delete_contains 4 6 2 4 6</kbd>
<kbd>2</kbd>
[4, 6, 4, 6]
<kbd is="sh">./list_delete_contains 42</kbd>
<kbd>42</kbd>
[]
<kbd is="sh">./list_delete_contains</kbd>
<kbd>42</kbd>
[]
</pre>




<h4>Assumptions/Restrictions/Clarifications.</h4>

<b>delete_contains</b> should call <b>free</b> to free the memory for the node it deletes
<p>
<b>delete_first</b> should not change the data fields of list nodes.
<p>
<b>delete_contains</b> should not use arrays.
<p>
<b>delete_contains</b> should not call malloc.
<p>
<b>delete_contains</b> should not call scanf (or getchar or fgets).
<p>
<b>delete_contains</b> should not print anything. It should not call printf.
<p>
Do not change the supplied <b>main</b> function. It will not be tested or marked.









<div class="alert alert-info">
<strong>New!</strong>
You can run an automated code style checker using the following command:

<pre is="tty">
<kbd is="sh">1511 style list_delete_contains.c</kbd>
</pre>
</div>




<p>
When you think your program is working,
you can use <code>autotest</code>
to run some simple automated tests:

<pre is="tty">
<kbd is="sh">1511 autotest list_delete_contains</kbd>
</pre>
















<p>
When you are finished working on this exercise,

you and your lab partner must both

submit your work by running <code>give</code>:

<pre is="tty">
<kbd is="sh">give cs1511 lab09_list_delete_contains list_delete_contains.c</kbd>
</pre>

<p>

Note, even though this is a pair exercise,
you both must run <code>give</code> from your own account

before <strong>Sunday 15 November 20:00</strong>
to obtain the marks for this lab exercise.






    
        
        
            
            <div class="answer">
                Sample solution for <code>list_delete_contains.c</code>
                
<div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;assert.h&gt;</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">node</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
    <span class="kt">int</span>          <span class="n">data</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="nf">delete_contains</span><span class="p">(</span><span class="kt">int</span> <span class="n">value</span><span class="p">,</span> <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">head</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="nf">strings_to_list</span><span class="p">(</span><span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">strings</span><span class="p">[]);</span>
<span class="kt">void</span> <span class="nf">print_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">head</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">value</span><span class="p">;</span>
    <span class="n">scanf</span><span class="p">(</span><span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">value</span><span class="p">);</span>
    <span class="c1">// create linked list from command line arguments</span>
    <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">head</span> <span class="o">=</span> <span class="n">strings_to_list</span><span class="p">(</span><span class="n">argc</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>

    <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">new_head</span> <span class="o">=</span> <span class="n">delete_contains</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">head</span><span class="p">);</span>
    <span class="n">print_list</span><span class="p">(</span><span class="n">new_head</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="c1">// Delete the first node in the list containing i</span>
<span class="c1">// The deleted node is freed.</span>
<span class="c1">// If no node contains i, the list is not changed</span>
<span class="c1">// The head of the list is returned.</span>

<span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="nf">delete_contains</span><span class="p">(</span><span class="kt">int</span> <span class="n">value</span><span class="p">,</span> <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">head</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">head</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// list is empty no node to delete</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">==</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// deleting the first node</span>
        <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">new_head</span> <span class="o">=</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="n">free</span><span class="p">(</span><span class="n">head</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">new_head</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// first node is the only node</span>
        <span class="c1">// first node is definitely not value</span>
        <span class="k">return</span> <span class="n">head</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">n</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
    <span class="c1">// find node before first node containing i</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">!=</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">==</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">new_next</span> <span class="o">=</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="n">free</span><span class="p">(</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">);</span>
        <span class="n">n</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">new_next</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">head</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// create linked list from array of strings</span>
<span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="nf">strings_to_list</span><span class="p">(</span><span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">strings</span><span class="p">[])</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">head</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">n</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span> <span class="p">(</span><span class="k">struct</span> <span class="n">node</span><span class="p">));</span>
        <span class="n">assert</span><span class="p">(</span><span class="n">n</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
        <span class="n">n</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
        <span class="n">n</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">atoi</span><span class="p">(</span><span class="n">strings</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="n">head</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
        <span class="n">i</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>   
    <span class="k">return</span> <span class="n">head</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// print linked list</span>
<span class="kt">void</span> <span class="nf">print_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">head</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;[&quot;</span><span class="p">);</span>    
    <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">n</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">n</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// If you&#39;re getting an error here,</span>
        <span class="c1">// you have returned an invalid list</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">&quot;, &quot;</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


                
            </div>
            
        
    



    </section>

 






    


<section class="exercise with-pair">
    <header><h3><small style="font-variant: small-caps; text-transform: lowercase;">Exercise — in pairs:
    </small><br />Determine how many elements are the same in two lists</h3></header>
    











<p>
Download list_intersection_size.c <a href="https://cgi.cse.unsw.edu.au/~cs1511/20T3/activities/list_intersection_size/list_intersection_size.c">here</a>, or copy it to your CSE
account using the following command:

<pre is="tty">
<kbd is="sh">cp -n /web/cs1511/20T3/activities/list_intersection_size/list_intersection_size.c .</kbd>
</pre>




<p>
Your task is to add code to this function in <b>list_intersection_size.c</b>:


<div class="highlight"><pre><span></span><span class="c1">// return the number of values which occur in both linked lists</span>
<span class="c1">// no value is repeated in either list</span>
<span class="kt">int</span> <span class="nf">intersection_size</span><span class="p">(</span><span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">head1</span><span class="p">,</span> <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">head2</span><span class="p">)</span> <span class="p">{</span>

    <span class="c1">// PUT YOUR CODE HERE (change the next line!)</span>
    <span class="k">return</span> <span class="mi">42</span><span class="p">;</span>

<span class="p">}</span>
</pre></div>





Note <b>list_intersection_size.c</b> uses the following familiar data type:

<pre class="program">
struct node {
    struct node *next;
    int          data;
};
</pre>

<b>intersection_size</b> is given two arguments, <b>head1</b> and <b>head2</b>, which are pointers to the first node of linked lists.
<p>
Add code to <b>intersection_size</b> so that its returns the number of values that occur in both linked list.
<p>
Assume no value occurs more than once in either linked list.
<p>
For example, if the two lists contain these values:
<p>
<pre>
3, 1, 4
2, 7, 1, 8, 3
</pre>
<p>
<b>intersection_size</b> should return <b>2</b>, because these 2 elements occur in both lists:
<p>
<pre>
1, 3
</pre>
<p>

<h4>Testing</h4>

<b>list_intersection_size.c</b> also contains a <b>main</b> function which allows you to test your <b>intersection_size</b> function.
<p>
This main function:
<ul>
<li> uses a command line argument of "-" to separate the values for two linked lists.
<li> converts the command-line arguments before the "-" to a linked list
<li> assigns a pointer to the first node in the linked list to <b>head1</b>
<li> converts the command-line arguments after the "-" to a linked list
<li> assigns a pointer to the first node in the linked list to <b>head2</b>
<li> calls <b>intersection_size(head1, head2)</b>
<li> prints the result.
</ul>
<p>
Do not change this main function.  If you want to change it, you have misread the question.
<p>
Your <b>intersection_size</b> function will be called directly in marking.  The main function is only to let you test your <b>intersection_size</b> function
<p>
Here is how the main function allows you to test <b>intersection_size</b>:
<p>

<pre is="tty">
<kbd is="sh">cp -n /web/cs1511/20T3/activities/list_intersection_size/list_intersection_size.c .</kbd>
<kbd is="sh">dcc list_intersection_size.c -o list_intersection_size</kbd>
<kbd is="sh">./list_intersection_size 3 1 4 - 2 7 1 8 3</kbd>
2
<kbd is="sh">./list_intersection_size 16 7 8 12 - 13 19 21 12</kbd>
1
<kbd is="sh">./list_intersection_size 2 4 6 - 2 4 6</kbd>
3
<kbd is="sh">./list_intersection_size 3 5 7 11 13 - 15 17 19 23 29</kbd>
0
<kbd is="sh">./list_intersection_size 1 2 3 4 - 3 2 1</kbd>
3
<kbd is="sh">./list_intersection_size - 1 2 3 4</kbd>
0
<kbd is="sh">./list_intersection_size 4 3 2 1 -</kbd>
0
<kbd is="sh">./list_intersection_size -</kbd>
0
</pre>




<h4>Assumptions/Restrictions/Clarifications.</h4>

<b>intersection_size</b> should return a single integer.
<p>
No value will occur more than once in either linked list.
<p>
<b>intersection_size</b> should not change the linked lists it is given.
Your function should not change the next or data fields of list nodes.
<p>
<b>intersection_size</b> should not use arrays.
<p>
<b>intersection_size</b> should not call malloc.
<p>
<b>intersection_size</b> should not call scanf (or getchar or fgets).
<p>
<b>intersection_size</b> should not print anything. It should not call printf.
<p>
Do not change the supplied <b>main</b> function. It will not be tested or marked.









<div class="alert alert-info">
<strong>New!</strong>
You can run an automated code style checker using the following command:

<pre is="tty">
<kbd is="sh">1511 style list_intersection_size.c</kbd>
</pre>
</div>




<p>
When you think your program is working,
you can use <code>autotest</code>
to run some simple automated tests:

<pre is="tty">
<kbd is="sh">1511 autotest list_intersection_size</kbd>
</pre>
















<p>
When you are finished working on this exercise,

you and your lab partner must both

submit your work by running <code>give</code>:

<pre is="tty">
<kbd is="sh">give cs1511 lab09_list_intersection_size list_intersection_size.c</kbd>
</pre>

<p>

Note, even though this is a pair exercise,
you both must run <code>give</code> from your own account

before <strong>Sunday 15 November 20:00</strong>
to obtain the marks for this lab exercise.






    
        
        
            
            <div class="answer">
                Sample solution for <code>list_intersection_size.c</code>
                
<div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;assert.h&gt;</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">node</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
    <span class="kt">int</span>          <span class="n">data</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">intersection_size</span><span class="p">(</span><span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">head1</span><span class="p">,</span> <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">head2</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">member</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">head</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="nf">strings_to_list</span><span class="p">(</span><span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">strings</span><span class="p">[]);</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="c1">// create two linked lists from command line arguments</span>
    <span class="kt">int</span> <span class="n">dash_arg</span> <span class="o">=</span> <span class="n">argc</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">dash_arg</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">strcmp</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="n">dash_arg</span><span class="p">],</span> <span class="s">&quot;-&quot;</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">dash_arg</span> <span class="o">=</span> <span class="n">dash_arg</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">head1</span> <span class="o">=</span> <span class="n">strings_to_list</span><span class="p">(</span><span class="n">dash_arg</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
    <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">head2</span> <span class="o">=</span> <span class="n">strings_to_list</span><span class="p">(</span><span class="n">argc</span> <span class="o">-</span> <span class="n">dash_arg</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">argv</span><span class="p">[</span><span class="n">dash_arg</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]);</span>

    <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">intersection_size</span><span class="p">(</span><span class="n">head1</span><span class="p">,</span> <span class="n">head2</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// return the number of values which occur in both linked lists</span>
<span class="c1">// no value is repeated in either list</span>
<span class="kt">int</span> <span class="nf">intersection_size</span><span class="p">(</span><span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">head1</span><span class="p">,</span> <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">head2</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">num_both</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">head1</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">p</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">member</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">head2</span><span class="p">))</span> <span class="p">{</span>
            <span class="n">num_both</span> <span class="o">=</span> <span class="n">num_both</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">num_both</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// return 1 if i occurs in list, 0 otherwise</span>
<span class="kt">int</span> <span class="nf">member</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">head</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">p</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">==</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="c1">// create linked list from array of strings</span>
<span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="nf">strings_to_list</span><span class="p">(</span><span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">strings</span><span class="p">[])</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">head</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">n</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span> <span class="p">(</span><span class="k">struct</span> <span class="n">node</span><span class="p">));</span>
        <span class="n">assert</span><span class="p">(</span><span class="n">n</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
        <span class="n">n</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
        <span class="n">n</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">atoi</span><span class="p">(</span><span class="n">strings</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="n">head</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">head</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


                
                    Alternative solution for <code>list_intersection_size.c</code>
                    
<div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">node</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
    <span class="kt">int</span>          <span class="n">data</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// return 1 if i  occurs in list, 0 otherwise</span>
<span class="kt">int</span> <span class="nf">member</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">head</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">head</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">if</span> <span class="p">(</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">==</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">member</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// return the number of values which occur in both linked lists</span>
<span class="c1">// no value is repeated in either list</span>
<span class="c1">// cute, recursive solution</span>
<span class="kt">int</span> <span class="nf">intersection_size</span><span class="p">(</span><span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">head1</span><span class="p">,</span> <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">head2</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">head1</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">member</span><span class="p">(</span><span class="n">head1</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">head2</span><span class="p">)</span> <span class="o">+</span> <span class="n">intersection_size</span><span class="p">(</span><span class="n">head1</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">,</span> <span class="n">head2</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>

                
            </div>
            
        
    



    </section>

 






    


<section class="exercise with-self">
    <header><h3><small style="font-variant: small-caps; text-transform: lowercase;">Challenge Exercise — individual:
    </small><br />Determine whether a list of lists contains a diagonal line of identical values</h3></header>
    











<p>
Download lists_diagonal.c <a href="https://cgi.cse.unsw.edu.au/~cs1511/20T3/activities/lists_diagonal/lists_diagonal.c">here</a>, or copy it to your CSE
account using the following command:

<pre is="tty">
<kbd is="sh">cp -n /web/cs1511/20T3/activities/lists_diagonal/lists_diagonal.c .</kbd>
</pre>




<p>
Your task is to add code to this function in <b>lists_diagonal.c</b>:


<div class="highlight"><pre><span></span><span class="c1">// Treat the linked lists like they&#39;re a 2D array</span>
<span class="c1">// and return 1 if the first element is repeated</span>
<span class="c1">// diagonally through the lists</span>
<span class="kt">int</span> <span class="nf">has_diagonal</span><span class="p">(</span><span class="k">struct</span> <span class="n">list_node</span> <span class="o">*</span><span class="n">head</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>





<b>lists_diagonal</b> is written using the following structs that cannot be changed:
<p>
<pre>
struct node {
    int data;
    struct node *next;
};

struct list_node {
    struct node *my_list;
    struct list_node *next;
};
</pre>
<p>
The <b>node</b> struct is a normal linked list node.
<p>
The <b>list_node</b> struct is used to make a linked list where each element 
contains a list of <b>node</b>s.
<p> 
<b>has_diagonal</b> should take a pointer to the head of a <b>list_node</b> list
and return a 1 if it finds a diagonal or a 0 if it doesn't. A diagonal in this
exercise means that the first number in the first list is the same as the second
number in the second list and the third number in the third list and so on.
<p>
For example if the list of lists looks like this:
<p>
<pre>
list_node 0 contains the list {5, 0, 0}
list_node 1 contains the list {0, 5, 0}
list_node 2 contains the list {0, 0, 5}
</pre>
<p>
<b>has_diagonal</b> should return 1.
<p>However, if the list of lists looks like this:
<p>
<pre>
list_node 0 contains the list {5, 0, 0, 0}
list_node 1 contains the list {0, 4, 0, 0}
list_node 2 contains the list {0, 0, 5, 0}
list_node 3 contains the list {0, 0, 0, 5}
</pre>
<p>
<b>has_diagonal</b> should return 0, because the 2nd element of the second list
does not equal the value of the first element of the first list.
<h4>Assumptions/Restrictions/Clarifications.</h4>
<p>
<b>struct node</b> and <b>struct list_node</b> cannot be edited. They must be used 
as they are.
<p>
You may not use arrays in this solution. Arrays are not necessary to complete this
task.
<p>
You can assume that you'll never receive an empty list of <b>list_node</b>s.
<p>
You can assume that all lists of <b>node</b>s are also not empty.
<p>
You can assume that there will always be the same number of <b>node</b>s in each
list and that will be the same number of <b>list_node</b>s. That is to say, the
2D grid formed by the lists will always be square.
Your submitted file may contain a main function. It will not be tested or marked.









<div class="alert alert-info">
<strong>New!</strong>
You can run an automated code style checker using the following command:

<pre is="tty">
<kbd is="sh">1511 style lists_diagonal.c</kbd>
</pre>
</div>




<p>
When you think your program is working,
you can use <code>autotest</code>
to run some simple automated tests:

<pre is="tty">
<kbd is="sh">1511 autotest lists_diagonal</kbd>
</pre>
















<p>
When you are finished working on this exercise,

you must

submit your work by running <code>give</code>:

<pre is="tty">
<kbd is="sh">give cs1511 lab09_lists_diagonal lists_diagonal.c</kbd>
</pre>

<p>

You must run <code>give</code>

before <strong>Sunday 15 November 20:00</strong>
to obtain the marks for this lab exercise.


Note that this is an individual exercise,
the work you submit with <code>give</code> must be entirely your own.





    
        
        
            
            <div class="answer">
                Sample solution for <code>lists_diagonal.c</code>
                
<div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp"></span>

<span class="c1">// Do not edit these structs. You may use them exactly as</span>
<span class="c1">// they are but you cannot make changes to them</span>

<span class="c1">// A node in a linked list</span>
<span class="k">struct</span> <span class="n">node</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">data</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// a list_node in a linked list. Each list_node</span>
<span class="c1">// contains a list of nodes.</span>
<span class="k">struct</span> <span class="n">list_node</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">my_list</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">list_node</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// Treat the linked lists like they&#39;re a 2D array</span>
<span class="c1">// and return 1 if the first element is repeated</span>
<span class="c1">// diagonally through the lists</span>
<span class="kt">int</span> <span class="nf">has_diagonal</span><span class="p">(</span><span class="k">struct</span> <span class="n">list_node</span> <span class="o">*</span><span class="n">head</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">has</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="c1">// assuming that we&#39;re never getting an empty first list</span>
    <span class="kt">int</span> <span class="n">number</span> <span class="o">=</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">my_list</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">head</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">n</span> <span class="o">=</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">my_list</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">n</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">j</span> <span class="o">==</span> <span class="n">i</span> <span class="o">&amp;&amp;</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">!=</span> <span class="n">number</span><span class="p">)</span> <span class="p">{</span>
                <span class="c1">// we&#39;re at the diagonal and they&#39;re not equal</span>
                <span class="n">has</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
            <span class="n">j</span><span class="o">++</span><span class="p">;</span>            
        <span class="p">}</span>
        <span class="n">i</span><span class="o">++</span><span class="p">;</span>
        <span class="n">head</span> <span class="o">=</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">has</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// This helper function is for the main below and will</span>
<span class="c1">// have no effect on your has_diagonal. It does not</span>
<span class="c1">// need to be modified.</span>
<span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="nf">make_list</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">,</span> <span class="kt">int</span> <span class="n">c</span><span class="p">);</span>

<span class="c1">// This is a main function which could be used</span>
<span class="c1">// to test your has_diagonal function.</span>
<span class="c1">// It will not be marked.</span>
<span class="c1">// Only your has_diagonal function will be marked.</span>
<span class="c1">//</span>
<span class="c1">// It&#39;s recommended to change the int values in this</span>
<span class="c1">// main to test whether your has_diagonal is working.</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">list_node</span> <span class="o">*</span><span class="n">head</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span> <span class="p">(</span><span class="k">struct</span> <span class="n">list_node</span><span class="p">));</span>
    <span class="k">struct</span> <span class="n">list_node</span> <span class="o">*</span><span class="n">l</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
    
    <span class="c1">// create the first list</span>
    <span class="n">l</span><span class="o">-&gt;</span><span class="n">my_list</span> <span class="o">=</span> <span class="n">make_list</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    
    <span class="c1">// create the second list</span>
    <span class="n">l</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span> <span class="p">(</span><span class="k">struct</span> <span class="n">list_node</span><span class="p">));</span>
    <span class="n">l</span> <span class="o">=</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="n">l</span><span class="o">-&gt;</span><span class="n">my_list</span> <span class="o">=</span> <span class="n">make_list</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    
    <span class="c1">// create the third list</span>
    <span class="n">l</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span> <span class="p">(</span><span class="k">struct</span> <span class="n">list_node</span><span class="p">));</span>
    <span class="n">l</span> <span class="o">=</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="n">l</span><span class="o">-&gt;</span><span class="n">my_list</span> <span class="o">=</span> <span class="n">make_list</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>
    <span class="n">l</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;The result of has_diagonal is: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">has_diagonal</span><span class="p">(</span><span class="n">head</span><span class="p">));</span>
    
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="nf">make_list</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">,</span> <span class="kt">int</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">head</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span> <span class="p">(</span><span class="k">struct</span> <span class="n">node</span><span class="p">));</span>
    <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">n</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
    <span class="n">n</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
    <span class="n">n</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span> <span class="p">(</span><span class="k">struct</span> <span class="n">node</span><span class="p">));</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="n">n</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>
    <span class="n">n</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span> <span class="p">(</span><span class="k">struct</span> <span class="n">node</span><span class="p">));</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="n">n</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span>
    <span class="n">n</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    
    <span class="k">return</span> <span class="n">head</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


                
            </div>
            
        
    



    </section>

 






    


<section class="exercise with-self">
    <header><h3><small style="font-variant: small-caps; text-transform: lowercase;">Challenge Exercise — individual:
    </small><br />Play the Game of Chairs. Win or die.</h3></header>
    











<p>
Download musical_chairs.c <a href="https://cgi.cse.unsw.edu.au/~cs1511/20T3/activities/musical_chairs/musical_chairs.c">here</a>, or copy it to your CSE
account using the following command:

<pre is="tty">
<kbd is="sh">cp -n /web/cs1511/20T3/activities/musical_chairs/musical_chairs.c .</kbd>
</pre>




<p>
Your task is to add code to this function in <b>musical_chairs.c</b>:


<div class="highlight"><pre><span></span><span class="c1">// Make music for a certain number of turns.</span>
<span class="c1">// Each turn of music makes the players move</span>
<span class="c1">// one chair along the list.</span>
<span class="c1">// After they&#39;ve moved that many times, the</span>
<span class="c1">// first chair in the list is removed, along</span>
<span class="c1">// with the person sitting in it.</span>
<span class="k">struct</span> <span class="n">chair</span> <span class="o">*</span><span class="nf">make_music</span><span class="p">(</span><span class="kt">int</span> <span class="n">turns</span><span class="p">,</span> <span class="k">struct</span> <span class="n">chair</span> <span class="o">*</span><span class="n">chairs</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// IMPLEMENT THIS FUNCTION</span>
    <span class="k">return</span> <span class="n">chairs</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>




<p>
Welcome to the Game of Chairs, where you either win or have your memory freed.
<p>
<b>musical_chairs</b> is written using the following structs that cannot be changed:
<p>

<div class="highlight"><pre><span></span><span class="c1">// player in the game of chairs</span>
<span class="k">struct</span> <span class="n">player</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="n">MAX_NAME_LENGTH</span><span class="p">];</span>
<span class="p">};</span>

<span class="c1">// A node in a linked list of chairs</span>
<span class="k">struct</span> <span class="n">chair</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">player</span> <span class="o">*</span><span class="n">sitting</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">chair</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>

<p>
The <b>chair</b> struct is a linked list node.
<p>
The <b>player</b> struct represents a player that can sit on a chair
(represented by the chair's pointer aiming at the player).
<p> 
<b>make_music</b> is given a pointer to a <b>chair</b>, which is the
first element in a list of chairs. It is also given an int <b>turns</b>
which represents how many turns of movement there will be before
the music stops.
<p>Like the game of
<a href="https://en.wikipedia.org/wiki/Musical_chairs">Musical Chairs</a>,
this program will have players move along the linked list, changing
which chair they're sitting in.
<p>In <b>make_music</b>, every player moves <b>turns</b> spaces along
the linked list. Anyone who moves off the end of the linked list, should
then move to the head of the list, so the players will end up rotating
through the list as if it's a loop. This would be similar to if the
<b>next</b> of the last chair was aimed at the first chair.
<p>Once all the players have finished moving, the head of the list of
chairs is removed. This means both that chair and the player sitting in
it are removed from the game. 
<p><b>make_music</b> should then print out the name of the player that
was removed.
<p>Be careful to make sure you free all memory used in this game!
<p>
For example if a list of chairs called <b>thrones</b> looks like this:
<p>
<pre>
throne points at the player named "Spoiler Alert"
throne points at the player named "Eddard Stark"
throne points at the player named "Joffrey Baratheon"
throne points at the player named "Cersei Lannister"
throne points at the player named "Robert Baratheon"
</pre>
<p>
Then the following function is called:
<p>

<div class="highlight"><pre><span></span><span class="n">make_music</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">thrones</span><span class="p">);</span>
</pre></div>

<p>
The output would be:
<p>
<pre>
Joffrey Baratheon
</pre>
<p>
and the resulting linked list would look like this:
<p>
<pre>
(throne pointed at "Joffrey Baratheon" but was removed)
throne points at the player named "Cersei Lannister"
throne points at the player named "Robert Baratheon"
throne points at the player named "Spoiler Alert"
throne points at the player named "Eddard Stark"
</pre>
<p>
In this list, all the players have moved down 3 chairs and are now sitting in
different chairs. Anyone that moved past the end of the chairs was moved back
to the top of the list of chairs.
<h4>Assumptions/Restrictions/Clarifications.</h4>
<p>
You can assume the list provided to <code>make_music</code> will not be empty.
You can assume the number of turns will not be negative.
<p>
<b>struct player</b> and <b>struct chair</b> cannot be edited. They must be
used as they are.
<p>
The <b>be_seated</b> function will help you create chairs. It cannot be edited
and must be used as it is.
<p>
You may not use arrays in this solution. Arrays are not necessary to 
complete this task.
<p>
You must free all memory used in your program. Use 
<code>dcc --leak-check</code> if you need to check for memory leaks. Autotest
will also check your code for leaks
Your submitted file may contain a main function. It will not be tested or marked.









<div class="alert alert-info">
<strong>New!</strong>
You can run an automated code style checker using the following command:

<pre is="tty">
<kbd is="sh">1511 style musical_chairs.c</kbd>
</pre>
</div>




<p>
When you think your program is working,
you can use <code>autotest</code>
to run some simple automated tests:

<pre is="tty">
<kbd is="sh">1511 autotest musical_chairs</kbd>
</pre>
















<p>
When you are finished working on this exercise,

you must

submit your work by running <code>give</code>:

<pre is="tty">
<kbd is="sh">give cs1511 lab09_musical_chairs musical_chairs.c</kbd>
</pre>

<p>

You must run <code>give</code>

before <strong>Sunday 15 November 20:00</strong>
to obtain the marks for this lab exercise.


Note that this is an individual exercise,
the work you submit with <code>give</code> must be entirely your own.





    
        
        
            
            <div class="answer">
                Sample solution for <code>musical_chairs.c</code>
                
<div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp"></span>

<span class="cp">#define MAX_NAME_LENGTH 100</span>

<span class="c1">// Do not edit these structs. You may use them exactly as</span>
<span class="c1">// they are but you cannot make changes to them</span>

<span class="c1">// player in the game of chairs</span>
<span class="k">struct</span> <span class="n">player</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="n">MAX_NAME_LENGTH</span><span class="p">];</span>
<span class="p">};</span>

<span class="c1">// A node in a linked list of chairs</span>
<span class="k">struct</span> <span class="n">chair</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">player</span> <span class="o">*</span><span class="n">sitting</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">chair</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// Move the players along to the next chair</span>
<span class="c1">// The chairs are acting as a loop, so if </span>
<span class="c1">// a player moves off the end of the list,</span>
<span class="c1">// they&#39;ll end up back at the start</span>
<span class="kt">void</span> <span class="nf">move_players</span><span class="p">(</span><span class="k">struct</span> <span class="n">chair</span> <span class="o">*</span><span class="n">chairs</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">chair</span> <span class="o">*</span><span class="n">c</span> <span class="o">=</span> <span class="n">chairs</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">player</span> <span class="o">*</span><span class="n">unseated</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">c</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">struct</span> <span class="n">player</span> <span class="o">*</span><span class="n">moving</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">sitting</span><span class="p">;</span>
        <span class="n">c</span><span class="o">-&gt;</span><span class="n">sitting</span> <span class="o">=</span> <span class="n">unseated</span><span class="p">;</span>
        <span class="n">unseated</span> <span class="o">=</span> <span class="n">moving</span><span class="p">;</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// the last unseated then goes back to the</span>
    <span class="c1">// first chair</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">chairs</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">chairs</span><span class="o">-&gt;</span><span class="n">sitting</span> <span class="o">=</span> <span class="n">unseated</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Make music for a certain number of turns</span>
<span class="c1">// Each turn of music makes the players move</span>
<span class="c1">// one chair along the list.</span>
<span class="c1">// After they&#39;ve moved that many times, the</span>
<span class="c1">// first chair in the list is removed, along</span>
<span class="c1">// with the person sitting in it</span>
<span class="k">struct</span> <span class="n">chair</span> <span class="o">*</span><span class="nf">make_music</span><span class="p">(</span><span class="kt">int</span> <span class="n">turns</span><span class="p">,</span> <span class="k">struct</span> <span class="n">chair</span> <span class="o">*</span><span class="n">chairs</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">turns</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">move_players</span><span class="p">(</span><span class="n">chairs</span><span class="p">);</span>
        <span class="n">i</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// remove the head!</span>
    <span class="k">struct</span> <span class="n">chair</span> <span class="o">*</span><span class="n">beheaded</span> <span class="o">=</span> <span class="n">chairs</span><span class="p">;</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">beheaded</span><span class="o">-&gt;</span><span class="n">sitting</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
    <span class="n">chairs</span> <span class="o">=</span> <span class="n">chairs</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="n">free</span><span class="p">(</span><span class="n">beheaded</span><span class="o">-&gt;</span><span class="n">sitting</span><span class="p">);</span>
    <span class="n">free</span><span class="p">(</span><span class="n">beheaded</span><span class="p">);</span>
    
    <span class="k">return</span> <span class="n">chairs</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// This helper function is only for this main, but</span>
<span class="c1">// it may help you to both understand and test this exercise.</span>
<span class="c1">// You may use this function for testing, but</span>
<span class="c1">// YOU CANNOT CHANGE THIS FUNCTION</span>
<span class="k">struct</span> <span class="n">chair</span> <span class="o">*</span><span class="nf">be_seated</span><span class="p">(</span><span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="n">MAX_NAME_LENGTH</span><span class="p">],</span> <span class="k">struct</span> <span class="n">chair</span> <span class="o">*</span><span class="n">heir</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">chair</span> <span class="o">*</span><span class="n">c</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">chair</span><span class="p">));</span>
    <span class="n">c</span><span class="o">-&gt;</span><span class="n">sitting</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">player</span><span class="p">));</span>
    <span class="n">strcpy</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">sitting</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
    <span class="n">c</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">heir</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">c</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// This is a main function which could be used</span>
<span class="c1">// to test your make_music function.</span>
<span class="c1">// It will not be marked.</span>
<span class="c1">// Only your make_music function will be marked.</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">chair</span> <span class="o">*</span><span class="n">thrones</span> <span class="o">=</span> <span class="n">be_seated</span><span class="p">(</span><span class="s">&quot;Robert Baratheon&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="n">thrones</span> <span class="o">=</span> <span class="n">be_seated</span><span class="p">(</span><span class="s">&quot;Cersei Lannister&quot;</span><span class="p">,</span> <span class="n">thrones</span><span class="p">);</span>
    <span class="n">thrones</span> <span class="o">=</span> <span class="n">be_seated</span><span class="p">(</span><span class="s">&quot;Joffrey Baratheon&quot;</span><span class="p">,</span> <span class="n">thrones</span><span class="p">);</span>
    <span class="n">thrones</span> <span class="o">=</span> <span class="n">be_seated</span><span class="p">(</span><span class="s">&quot;Eddard Stark&quot;</span><span class="p">,</span> <span class="n">thrones</span><span class="p">);</span>
    <span class="n">thrones</span> <span class="o">=</span> <span class="n">be_seated</span><span class="p">(</span><span class="s">&quot;Spoiler Alert&quot;</span><span class="p">,</span> <span class="n">thrones</span><span class="p">);</span>
        
    <span class="n">thrones</span> <span class="o">=</span> <span class="n">make_music</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">thrones</span><span class="p">);</span>
    <span class="n">thrones</span> <span class="o">=</span> <span class="n">make_music</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">thrones</span><span class="p">);</span>
    <span class="n">thrones</span> <span class="o">=</span> <span class="n">make_music</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">thrones</span><span class="p">);</span>
    <span class="n">thrones</span> <span class="o">=</span> <span class="n">make_music</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">thrones</span><span class="p">);</span>

    <span class="n">free</span><span class="p">(</span><span class="n">thrones</span><span class="o">-&gt;</span><span class="n">sitting</span><span class="p">);</span>
    <span class="n">free</span><span class="p">(</span><span class="n">thrones</span><span class="p">);</span>
        
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


                
            </div>
            
        
    



    </section>





<section class="exercise ">
    <header><h3>Submission</h3></header>
    


When you are finished each exercises make sure you submit your work by running <code>give</code>.
<p>
You can run <code>give</code> multiple times.
Only your last submission will be marked.
<p>
Don't submit any exercises you haven't attempted.
<p>
If you are working at home, you may find it more convenient
to upload your work via
<a href="https://cgi.cse.unsw.edu.au/~give/Student/give.php">give's web interface</a>.
<p>
Remember you have until

<b>Week 9 Sunday 20:00</b>

to submit your work.
<p>
You cannot obtain marks by e-mailing your code to tutors or lecturers.
<p>
You check the files you have submitted <a href="https://cgi.cse.unsw.edu.au/~cs1511/20T3/student/">here</a>.
<p>
Automarking will be run by the lecturer several days after the submission deadline,
using test cases different to those <code>autotest</code> runs for you.
(Hint: do your own testing as well as running <code>autotest</code>.)
<p>
After automarking is run by the lecturer
you can <a href="https://cgi.cse.unsw.edu.au/~cs1511/20T3/student/">view your results here</a>.
The resulting mark will also be available
<a href="https://cgi.cse.unsw.edu.au/~give/Student/sturec.php">via give's web interface</a>.

<h4>Lab Marks</h4>
<p>
When all components of a lab  are automarked you should be able to view the
the marks <a href="https://cgi.cse.unsw.edu.au/~give/Student/sturec.php">via give's web interface</a>
or by running this command on a CSE machine:

<pre is="tty">
<kbd is="sh">1511 classrun -sturec</kbd>
</pre>










    </section>


</div>



</main>

<footer class="mt-3 pt-3 bg-dark text-center no-print">
<p class="text-muted">
<strong>COMP1511 20T3: Programming Fundamentals</strong>
is brought to you by <br />
the <a href="https://www.cse.unsw.edu.au/">School of Computer Science and Engineering</a><br />
at the <a href="https://www.unsw.edu.au/">University of New South Wales</a>, Sydney.<br />
For all enquiries, please email the class account at
<a href="mailto:@cse.unsw.edu.au">cs1511@cse.unsw.edu.au</a><br />

<small>CRICOS Provider 00098G</small>
</p>


</footer>

</body>
</html>