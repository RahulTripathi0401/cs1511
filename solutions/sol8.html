<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />

<title>
    
    COMP1511 20T3 - 
Week 08
Laboratory
Sample Solutions

    
</title><link rel="canonical" href="https://cgi.cse.unsw.edu.au/~cs1511/20T3/" />

<link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/css/bootstrap.min.css"
      integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh" crossorigin="anonymous">
<link rel="stylesheet" href="/~cs1511/20T3/flask.cgi/static/course.css?213751602407825.0" />

<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js"
        integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" crossorigin="anonymous"></script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js" integrity="sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6" crossorigin="anonymous"></script>
<script src="/~cs1511/20T3/flask.cgi/static/course.js?92151599736636.0"></script>


<link rel="icon" type="image/png" href="/~cs1511/20T3/flask.cgi/static/favicon.ico?1271605745352.0">

<!-- <script async src="https://static.codepen.io/assets/embed/ei.js"></script> -->

<!-- MathJax. -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.6/latest.js?config=TeX-MML-AM_CHTML" async="yes"></script>





</head>
<body class="d-flex flex-column" style="min-height: 100vh;">
  <nav class="navbar fixed-top navbar-expand-lg navbar-light no-print" id="header-navbar">
  <div class="container">
    <button class="navbar-toggler navbar-toggler-right"
            type="button" data-toggle="collapse" data-target="#navmenu"
            aria-controls="navmenu" aria-label="Toggle navigation" aria-expanded="false">
      <span class="navbar-toggler-icon"></span>
    </button>

    <a class="navbar-brand" href="https://cgi.cse.unsw.edu.au/~cs1511/20T3/">
      COMP1511 20T3
    </a>

    <div class="collapse navbar-collapse" id="navmenu">
      <ul class="navbar-nav mr-auto">
        <li class="nav-item active"><a class="nav-link" href="https://discourse.cse.unsw.edu.au/20t3/comp1511/">Forum</a></li>
        <li class="nav-item active"><a class="nav-link" href="https://cgi.cse.unsw.edu.au/~cs1511/20T3/student/">Submissions</a></li>

        
        <li class="nav-item active"><a class="nav-link" href="https://cgi.cse.unsw.edu.au/~cs1511/20T3/assignments/ass1/index.html">Assignment 1</a></li>
        

        
        <li class="nav-item active"><a class="nav-link" href="https://cgi.cse.unsw.edu.au/~cs1511/20T3/assignments/ass2/index.html">Assignment 2</a></li>
        

        <li class="navbar-text px-2">|</li>
        


    
        
        
        
        
    

    
        
        
        
        
    

    
        
        
        
        
    

    
        
        
        
        
    

    
        
        
        
        
    

    
        
        
        
        
    

    
        
        
        
        
    

    
        
        
        
        
    

    
        
        
        
        
    

    
        
        
        
        
    

    


<li class="nav-item active dropdown">
  <a role="button" class="nav-link dropdown-toggle" id="week-selector"
     href="#" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
    Week 08 <span class="caret"></span>
  </a>
  <div class="dropdown-menu" aria-labelledby="week-selector">
  
    <a class="dropdown-item" href="https://cgi.cse.unsw.edu.au/~cs1511/20T3/lab/01/answers">Week 01</a>
    <a class="dropdown-item" href="https://cgi.cse.unsw.edu.au/~cs1511/20T3/lab/02/answers">Week 02</a>
    <a class="dropdown-item" href="https://cgi.cse.unsw.edu.au/~cs1511/20T3/lab/03/answers">Week 03</a>
    <a class="dropdown-item" href="https://cgi.cse.unsw.edu.au/~cs1511/20T3/lab/04/answers">Week 04</a>
    <a class="dropdown-item" href="https://cgi.cse.unsw.edu.au/~cs1511/20T3/lab/05/answers">Week 05</a>
    <a class="dropdown-item" href="https://cgi.cse.unsw.edu.au/~cs1511/20T3/lab/06/answers">Week 06</a>
    <a class="dropdown-item" href="https://cgi.cse.unsw.edu.au/~cs1511/20T3/lab/07/answers">Week 07</a>
    <a class="dropdown-item" href="https://cgi.cse.unsw.edu.au/~cs1511/20T3/lab/08/answers">Week 08</a>
    <a class="dropdown-item" href="https://cgi.cse.unsw.edu.au/~cs1511/20T3/lab/09/answers">Week 09</a>
    <a class="dropdown-item" href="https://cgi.cse.unsw.edu.au/~cs1511/20T3/lab/10/answers">Week 10</a>
  </div>
</li>



    
        
        
        
        
    

    
        
        
        
        
    

    
        
        
        
        
    


<li class="nav-item active dropdown">
  <a role="button" class="nav-link dropdown-toggle" id="tlb-selector"
     href="#" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
    Laboratory <span class="caret"></span>
  </a>
  <div class="dropdown-menu" aria-labelledby="tlb-selector">
  
    <a class="dropdown-item" href="https://cgi.cse.unsw.edu.au/~cs1511/20T3/tut/08/answers">Tutorial</a>
    <a class="dropdown-item" href="https://cgi.cse.unsw.edu.au/~cs1511/20T3/lab/08/answers">Laboratory</a>
    <a class="dropdown-item" href="https://cgi.cse.unsw.edu.au/~cs1511/20T3/test/08/answers">Weekly Test</a>
  </div>
</li>



    
    
    
    

    
    
    
    



<li class="nav-item active dropdown">
  <a role="button" class="nav-link dropdown-toggle" id="qa-selector"
     href="#" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
    Sample Solutions <span class="caret"></span>
  </a>
  <div class="dropdown-menu" aria-labelledby="qa-selector">
  
    <a class="dropdown-item" href="https://cgi.cse.unsw.edu.au/~cs1511/20T3/lab/08/questions">Exercises</a>
    <a class="dropdown-item" href="https://cgi.cse.unsw.edu.au/~cs1511/20T3/lab/08/answers">Sample Solutions</a>
  </div>
</li>


      </ul>
    </div>
  </div>
</nav>


<main class="container" aria-label="Content" style="flex: 1; padding-top: 4rem;">


<header>

<h1 class="text-center">
Week 08
Laboratory
Sample Solutions
</h1>

</header>


<div class="tutlab lab">




<section class="exercise ">
    <header><h3>Objectives</h3></header>
    

<ul>

<li>working with structs and pointers</li>

<li>introducing linked lists</li>

<li>using memory allocation</li>

</ul>


    </section>



<section class="exercise ">
    <header><h3>Preparation</h3></header>
    


<p>
Before the lab you should re-read the relevant lecture slides and their accompanying examples.



    </section>









 






    


<section class="exercise with-pair">
    <header><h3><small style="font-variant: small-caps; text-transform: lowercase;">Exercise — in pairs:
    </small><br />Pet Statistics</h3></header>
    









In this exercise, you will read some pet information from standard input
and relay it in a human readable format.



<p>
Download pet_stats.c <a href="https://cgi.cse.unsw.edu.au/~cs1511/20T3/activities/pet_stats/pet_stats.c">here</a>, or copy it to your CSE
account using the following command:

<pre is="tty">
<kbd is="sh">cp -n /web/cs1511/20T3/activities/pet_stats/pet_stats.c .</kbd>
</pre>


<p>
<div class="alert alert-info">
    <b>New!</b> You can view a diagram explaining the code
    <b><a href="https://cgi.cse.unsw.edu.au/~cs1511/20T3/activities//pet_stats/pet_stats_diagram.png">here</a></b>
</div>

<b>pet_stats.c</b> already contains a struct for a pet and a main function. You
cannot change either of these and can only make changes to the functions: 
<b>setup_pet()</b> and <b>print_pet()</b>.
<p>
Your task in this exercise is first to complete the function <b>setup_pet()</b> 
so that it:
<ul>
<li>
Stores the first input string in the name field
<li>
Stores the second input string in the type field
<li>
Converts the third input string into an int and stores it in the age field
<li>
Converts the fourth input string into an int and stores it in the weight field
</ul>
<p>
<b>Hint:</b> You may need the strtol() function to convert a string into an int. <br>
You can assume each string contains at most 50 characters.
<p>
You will then need to complete the function <b>print_pet()</b> so that it writes
out a single line of text describing the pet, like: "Mr_Snuffle-uffle-kins is a 
cat who is 4 years old and weighs 6kg\n"
<p>
When you have completed the functions <b>setup_pet()</b> and <b>print_pet()</b>
 this is how <b>pet_stats.c</b> should behave:

<pre is="tty">
<kbd is="sh">dcc -o pet_stats pet_stats.c</kbd>
<kbd is="sh">./pet_stats Mr_Snuffle-uffle-kins cat 4 6</kbd>
Mr_Snuffle-uffle-kins is a cat who is 4 years old and weighs 6kg
<kbd is="sh">./pet_stats 007  British_Short-hair 35 78</kbd>
007 is a British_Short-hair who is 35 years old and weighs 78kg
</pre>









<div class="alert alert-info">
<strong>New!</strong>
You can run an automated code style checker using the following command:

<pre is="tty">
<kbd is="sh">1511 style pet_stats.c</kbd>
</pre>
</div>




<p>
When you think your program is working,
you can use <code>autotest</code>
to run some simple automated tests:

<pre is="tty">
<kbd is="sh">1511 autotest pet_stats</kbd>
</pre>
















<p>
When you are finished working on this exercise,

you and your lab partner must both

submit your work by running <code>give</code>:

<pre is="tty">
<kbd is="sh">give cs1511 lab08_pet_stats pet_stats.c</kbd>
</pre>

<p>

Note, even though this is a pair exercise,
you both must run <code>give</code> from your own account

before <strong>Sunday 08 November 20:00</strong>
to obtain the marks for this lab exercise.






    
        
        
            
            <div class="answer">
                Sample solution for <code>pet_stats.c</code>
                
<div class="highlight"><pre><span></span><span class="c1">// A program to track statistics of pets</span>
<span class="c1">// Written for COMP1511 tutorials by </span>
<span class="c1">// Marc Chee (marc.chee@unsw.edu.au)</span>
<span class="c1">// July 2019</span>

<span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp"></span>

<span class="cp">#define MAX_NAME_LENGTH 50</span>
<span class="cp">#define MAX_TYPE_LENGTH 50</span>

<span class="k">struct</span> <span class="n">pet</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="n">MAX_NAME_LENGTH</span><span class="p">];</span>
    <span class="kt">char</span> <span class="n">type</span><span class="p">[</span><span class="n">MAX_TYPE_LENGTH</span><span class="p">];</span>
    <span class="kt">int</span> <span class="n">age</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">weight</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">setup_pet</span><span class="p">(</span>
    <span class="k">struct</span> <span class="n">pet</span> <span class="o">*</span><span class="n">my_pet</span><span class="p">,</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> 
    <span class="kt">char</span> <span class="o">*</span><span class="n">type</span><span class="p">,</span> 
    <span class="kt">char</span> <span class="o">*</span><span class="n">age</span><span class="p">,</span> 
    <span class="kt">char</span> <span class="o">*</span><span class="n">weight</span>
<span class="p">);</span>
<span class="kt">void</span> <span class="nf">print_pet</span><span class="p">(</span><span class="k">struct</span> <span class="n">pet</span> <span class="o">*</span><span class="n">my_pet</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s should receive four extra command line arguments.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">struct</span> <span class="n">pet</span> <span class="n">new_pet</span><span class="p">;</span>
    <span class="n">setup_pet</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new_pet</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">argv</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">argv</span><span class="p">[</span><span class="mi">4</span><span class="p">]);</span>
    <span class="n">print_pet</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new_pet</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">setup_pet</span><span class="p">(</span>
    <span class="k">struct</span> <span class="n">pet</span> <span class="o">*</span><span class="n">my_pet</span><span class="p">,</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> 
    <span class="kt">char</span> <span class="o">*</span><span class="n">type</span><span class="p">,</span> 
    <span class="kt">char</span> <span class="o">*</span><span class="n">age</span><span class="p">,</span> 
    <span class="kt">char</span> <span class="o">*</span><span class="n">weight</span>
<span class="p">)</span> <span class="p">{</span>
    <span class="n">strcpy</span><span class="p">(</span><span class="n">my_pet</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
    <span class="n">strcpy</span><span class="p">(</span><span class="n">my_pet</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">,</span> <span class="n">type</span><span class="p">);</span>
    <span class="n">my_pet</span><span class="o">-&gt;</span><span class="n">age</span> <span class="o">=</span> <span class="n">strtol</span><span class="p">(</span><span class="n">age</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
    <span class="n">my_pet</span><span class="o">-&gt;</span><span class="n">weight</span> <span class="o">=</span> <span class="n">strtol</span><span class="p">(</span><span class="n">weight</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">print_pet</span><span class="p">(</span><span class="k">struct</span> <span class="n">pet</span> <span class="o">*</span><span class="n">my_pet</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">fputs</span><span class="p">(</span><span class="n">my_pet</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">stdout</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot; is a &quot;</span><span class="p">);</span>
    <span class="n">fputs</span><span class="p">(</span><span class="n">my_pet</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">,</span> <span class="n">stdout</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot; who is &quot;</span><span class="p">);</span>
    <span class="n">printf</span> <span class="p">(</span><span class="s">&quot;%d years old and weighs %dkg</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">my_pet</span><span class="o">-&gt;</span><span class="n">age</span><span class="p">,</span> <span class="n">my_pet</span><span class="o">-&gt;</span><span class="n">weight</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


                
            </div>
            
        
    



    </section>

 






    


<section class="exercise with-pair">
    <header><h3><small style="font-variant: small-caps; text-transform: lowercase;">Exercise — in pairs:
    </small><br />Print out the elements of a Linked List</h3></header>
    











<p>
Download list_print.c <a href="https://cgi.cse.unsw.edu.au/~cs1511/20T3/activities/list_print/list_print.c">here</a>, or copy it to your CSE
account using the following command:

<pre is="tty">
<kbd is="sh">cp -n /web/cs1511/20T3/activities/list_print/list_print.c .</kbd>
</pre>




<p>
Your task is to add code to this function in <b>list_print.c</b>:


<div class="highlight"><pre><span></span><span class="c1">// print a linked list in this format:</span>
<span class="c1">// 17 -&gt; 34 -&gt; 51 -&gt; 68 -&gt; X</span>
<span class="kt">void</span> <span class="nf">print</span><span class="p">(</span><span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">head</span><span class="p">)</span> <span class="p">{</span>

    <span class="c1">// PUT YOUR CODE HERE</span>
<span class="p">}</span>
</pre></div>





<b>print</b> is given  one argument, <b>head</b>, which is the pointer to the first node in a linked list.
<p>
Add code to <b>print</b> so that it prints the elements in the list
<p>
For example if the linked list contains these 8 elements:
<p>
<pre>
1, 7, 8, 9, 13, 19, 21, 42
</pre>
<p>
<b>print</b> should print <b>1 -> 7 -> 8 -> 9 -> 13 -> 19 -> 21 -> 42 -> X</b>

<h4>Testing</h4>

<b>list_print.c</b> also contains a <b>main</b> function which allows you to test your <b>print</b> function.
<p>
This main function:
<ul>
<li> converts the command-line arguments to a linked list
<li> assigns a pointer to the first node in the linked list to <b>head</b>
<li> calls <b>list_print(head)</b>
</ul>
<p>
<p>
Do not change this main function.  If you want to change it, you have misread the question.
<p>
Your <b>list_print</b> function will be called directly in marking.  The main function is only to let you test your <b>list_print</b> function
<p>
Here is how you use main function allows you to test <b>list_print</b>:
<p>

<pre is="tty">
<kbd is="sh">dcc list_print.c -o list_print</kbd>
<kbd is="sh">./list_print 1 2 4 8 16 32 64 128 256</kbd>
1 -> 2 -> 4 -> 8 -> 16 -> 32 -> 64 -> 128 -> 256 -> X
<kbd is="sh">./list_print 2 4 6 5 8 9</kbd>
2 -> 4 -> 6 -> 5 -> 8 -> 9 -> X
<kbd is="sh">./list_print 42 4</kbd>
42 -> 4 -> X
<kbd is="sh">./list_print 43</kbd>
43 -> X
<kbd is="sh">./list_print</kbd>
X
</pre>




<h4>Assumptions/Restrictions/Clarifications.</h4>

<b>print</b> should not change the linked list it is given.
Your function should not change the next or data fields of list nodes.
<p>
<b>print</b> should not use arrays.
<p>
<b>print</b> should not call malloc.
<p>
<b>print</b> should not call scanf (or getchar or fgets).
<p>
Do not change the supplied <b>main</b> function. It will not be tested or marked.









<div class="alert alert-info">
<strong>New!</strong>
You can run an automated code style checker using the following command:

<pre is="tty">
<kbd is="sh">1511 style list_print.c</kbd>
</pre>
</div>




<p>
When you think your program is working,
you can use <code>autotest</code>
to run some simple automated tests:

<pre is="tty">
<kbd is="sh">1511 autotest list_print</kbd>
</pre>
















<p>
When you are finished working on this exercise,

you and your lab partner must both

submit your work by running <code>give</code>:

<pre is="tty">
<kbd is="sh">give cs1511 lab08_list_print list_print.c</kbd>
</pre>

<p>

Note, even though this is a pair exercise,
you both must run <code>give</code> from your own account

before <strong>Sunday 08 November 20:00</strong>
to obtain the marks for this lab exercise.






    
        
        
            
            <div class="answer">
                Sample solution for <code>list_print.c</code>
                
<div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;assert.h&gt;</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">node</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
    <span class="kt">int</span>          <span class="n">data</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">print</span><span class="p">(</span><span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">head</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="nf">strings_to_list</span><span class="p">(</span><span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">strings</span><span class="p">[]);</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="c1">// create linked list from command line arguments</span>
    <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">head</span> <span class="o">=</span> <span class="n">strings_to_list</span><span class="p">(</span><span class="n">argc</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>

    <span class="n">print</span><span class="p">(</span><span class="n">head</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">//  print a linked list in this format:</span>
<span class="c1">// 17 -&gt; 34 -&gt; 51 -&gt; 68 -&gt; X</span>
<span class="kt">void</span> <span class="nf">print</span><span class="p">(</span><span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">head</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">n</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">n</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d -&gt; &quot;</span><span class="p">,</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>


<span class="c1">// create linked list from array of strings</span>
<span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="nf">strings_to_list</span><span class="p">(</span><span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">strings</span><span class="p">[])</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">head</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">n</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span> <span class="p">(</span><span class="k">struct</span> <span class="n">node</span><span class="p">));</span>
        <span class="n">assert</span><span class="p">(</span><span class="n">n</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
        <span class="n">n</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
        <span class="n">n</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">atoi</span><span class="p">(</span><span class="n">strings</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="n">head</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">head</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


                
                    Alternative solution for <code>list_print.c</code>
                    
<div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;assert.h&gt;</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">node</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
    <span class="kt">int</span>          <span class="n">data</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// print a linked list in this format:</span>
<span class="c1">// 17 -&gt; 34 -&gt; 51 -&gt; 68 -&gt; X</span>
<span class="kt">void</span> <span class="nf">print</span><span class="p">(</span><span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">head</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">head</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d -&gt; &quot;</span><span class="p">,</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
    <span class="n">print</span><span class="p">(</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>

                
            </div>
            
        
    



    </section>

 






    


<section class="exercise with-pair">
    <header><h3><small style="font-variant: small-caps; text-transform: lowercase;">Exercise — in pairs:
    </small><br />Insert an element at the head of a Linked List</h3></header>
    











<p>
Download list_insert_head.c <a href="https://cgi.cse.unsw.edu.au/~cs1511/20T3/activities/list_insert_head/list_insert_head.c">here</a>, or copy it to your CSE
account using the following command:

<pre is="tty">
<kbd is="sh">cp -n /web/cs1511/20T3/activities/list_insert_head/list_insert_head.c .</kbd>
</pre>




<p>
Your task is to add code to this function in <b>list_insert_head.c</b>:


<div class="highlight"><pre><span></span><span class="c1">// Insert a new node containing value at the start of the linked list.</span>
<span class="c1">// The head of the new list is returned.</span>
<span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="nf">insert_head</span><span class="p">(</span><span class="kt">int</span> <span class="n">value</span><span class="p">,</span> <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">head</span><span class="p">)</span> <span class="p">{</span>

    <span class="c1">// PUT YOUR CODE HERE (change the next line!)</span>
    <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

<span class="p">}</span>
</pre></div>





<b>insert_head</b> is given  two arguments, <b>value</b> and <b>head</b>.
<b>value</b> is an int.
<b>head</b> is the pointer to the first node in a linked list.
<p>
Add code to <b>insert_head</b> so that it creates a new list node (using malloc) containing value
and places it at the start of the list.
<p>
<b>insert_head</b> should return a pointer to the new list.
<p>
For example if <b>value</b> is <b>12</b> and the linked list contains these 3 elements:
<p>
<pre>
16, 7, 8
</pre>
<p>
<b>insert_head</b> should return a pointer to a list with these elements:
<p>
<pre>
12, 16, 7, 8
</pre>

<h4>Testing</h4>

<b>list_insert_head.c</b> also contains a <b>main</b> function which allows you to test your <b>insert_head</b> function.
<p>
This main function:
<ul>
<li> converts the command-line arguments to a linked list
<li> assigns a pointer to the first node in the linked list to <b>head</b>
<li> reads a single integer from standard input and assigns it to <b>value</b>
<li> calls <b>insert_head(value, head)</b>
<li> prints the result.
</ul>
<p>
Do not change this main function.  If you want to change it, you have misread the question.
<p>
Your <b>insert_head</b> function will be called directly in marking.  The main function is only to let you test your <b>insert_head</b> function
<p>

<pre is="tty">
<kbd is="sh">dcc list_insert_head.c -o list_insert_head</kbd>
<kbd is="sh">./list_insert_head 16 7 8</kbd>
<kbd>12</kbd>
[12, 16, 7, 8]
<kbd is="sh">./list_insert_head 16</kbd>
<kbd>42</kbd>
[42, 16]
<kbd is="sh">./list_insert_head</kbd>
<kbd>2</kbd>
[2]
</pre>

<h4>Assumptions/Restrictions/Clarifications.</h4>

<b>insert_head</b> should not use arrays.
<p>
<b>insert_head</b> should not call scanf (or getchar or fgets).
<p>
<b>insert_head</b> should not print anything. It should not call printf.
<p>
Do not change the supplied <b>main</b> function. It will not be tested or marked.









<div class="alert alert-info">
<strong>New!</strong>
You can run an automated code style checker using the following command:

<pre is="tty">
<kbd is="sh">1511 style list_insert_head.c</kbd>
</pre>
</div>




<p>
When you think your program is working,
you can use <code>autotest</code>
to run some simple automated tests:

<pre is="tty">
<kbd is="sh">1511 autotest list_insert_head</kbd>
</pre>
















<p>
When you are finished working on this exercise,

you and your lab partner must both

submit your work by running <code>give</code>:

<pre is="tty">
<kbd is="sh">give cs1511 lab08_list_insert_head list_insert_head.c</kbd>
</pre>

<p>

Note, even though this is a pair exercise,
you both must run <code>give</code> from your own account

before <strong>Sunday 08 November 20:00</strong>
to obtain the marks for this lab exercise.






    
        
        
            
            <div class="answer">
                Sample solution for <code>list_insert_head.c</code>
                
<div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;assert.h&gt;</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">node</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
    <span class="kt">int</span>          <span class="n">data</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="nf">insert_head</span><span class="p">(</span><span class="kt">int</span> <span class="n">value</span><span class="p">,</span> <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">head</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="nf">create_node</span><span class="p">(</span><span class="kt">int</span> <span class="n">data</span><span class="p">,</span> <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">next</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="nf">strings_to_list</span><span class="p">(</span><span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">strings</span><span class="p">[]);</span>
<span class="kt">void</span> <span class="nf">print_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">head</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">value</span><span class="p">;</span>
    <span class="n">scanf</span><span class="p">(</span><span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">value</span><span class="p">);</span>
    <span class="c1">// create linked list from command line arguments</span>
    <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">head</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// list has elements</span>
        <span class="n">head</span> <span class="o">=</span> <span class="n">strings_to_list</span><span class="p">(</span><span class="n">argc</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
    <span class="p">}</span>

    <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">new_head</span> <span class="o">=</span> <span class="n">insert_head</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">head</span><span class="p">);</span>
    <span class="n">print_list</span><span class="p">(</span><span class="n">new_head</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="c1">// Insert a new node containing value at the start of the linked list.</span>
<span class="c1">// The head of the new list is returned.</span>
<span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="nf">insert_head</span><span class="p">(</span><span class="kt">int</span> <span class="n">value</span><span class="p">,</span> <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">head</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">new_node</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span> <span class="p">(</span><span class="k">struct</span> <span class="n">node</span><span class="p">));</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">new_node</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;out of memory</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">new_node</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
    <span class="n">new_node</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">new_node</span><span class="p">;</span>
<span class="p">}</span>


<span class="c1">// create linked list from array of strings</span>
<span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="nf">strings_to_list</span><span class="p">(</span><span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">strings</span><span class="p">[])</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">head</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">n</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span> <span class="p">(</span><span class="k">struct</span> <span class="n">node</span><span class="p">));</span>
        <span class="n">assert</span><span class="p">(</span><span class="n">n</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
        <span class="n">n</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
        <span class="n">n</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">atoi</span><span class="p">(</span><span class="n">strings</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="n">head</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
        <span class="n">i</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>   
    <span class="k">return</span> <span class="n">head</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// print linked list</span>
<span class="kt">void</span> <span class="nf">print_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">head</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;[&quot;</span><span class="p">);</span>    
    <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">n</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">n</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// If you&#39;re getting an error here,</span>
        <span class="c1">// you have returned an invalid list</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">&quot;, &quot;</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


                
            </div>
            
        
    



    </section>

 






    


<section class="exercise with-pair">
    <header><h3><small style="font-variant: small-caps; text-transform: lowercase;">Exercise — in pairs:
    </small><br />Find an element in a Linked List</h3></header>
    











<p>
Download list_contains.c <a href="https://cgi.cse.unsw.edu.au/~cs1511/20T3/activities/list_contains/list_contains.c">here</a>, or copy it to your CSE
account using the following command:

<pre is="tty">
<kbd is="sh">cp -n /web/cs1511/20T3/activities/list_contains/list_contains.c .</kbd>
</pre>




<p>
Your task is to add code to this function in <b>list_contains.c</b>:


<div class="highlight"><pre><span></span><span class="c1">// Return 1 if value occurs in linked list, 0 otherwise</span>
<span class="kt">int</span> <span class="nf">contains</span><span class="p">(</span><span class="kt">int</span> <span class="n">value</span><span class="p">,</span> <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">head</span><span class="p">)</span> <span class="p">{</span>

    <span class="c1">// PUT YOUR CODE HERE (change the next line!)</span>
    <span class="k">return</span> <span class="mi">42</span><span class="p">;</span>

<span class="p">}</span>
</pre></div>





<b>contains</b> is given  two  arguments, an int <b>value</b> and <b>head</b>, which is the pointer to the first node in a linked list.
<p>
Add code to <b>contains</b> so that its returns 1 if <b>value</b> occurs in the linked and otherwise it returns 0.
<p>
For example if the linked list contains these 8 elements:
<p>
<pre>
1, 7, 8, 9, 13, 19, 21, 42
</pre>
<p>
and <b>contains</b> is called with <b>value</b> of 9,
<p>
<b>contains</b> should return <b>1</b>.

<h4>Testing</h4>

<b>list_contains.c</b> also contains a <b>main</b> function which allows you to test your <b>contains</b> function.
<p>
This main function:
<ul>
<li> converts the command-line arguments to a linked list
<li> assigns a pointer to the first node in the linked list to <b>head</b>
<li> reads a single integer from standard input and assigns it to <b>value</b>
<li> calls <b>list_contains(value, head)</b>
<li> prints the result.
</ul>
<p>
<p>
Do not change this main function.  If you want to change it, you have misread the question.
<p>
Your <b>list_contains</b> function will be called directly in marking.  The main function is only to let you test your <b>list_contains</b> function
<p>
Here is how you use main function allows you to test <b>list_contains</b>:
<p>

<pre is="tty">
<kbd is="sh">dcc list_contains.c -o list_contains</kbd>
<kbd is="sh">./list_contains 1 2 3 4</kbd>
<kbd>3</kbd>
1
<kbd is="sh">./list_contains 1 2 3 4</kbd>
<kbd>42</kbd>
0
<kbd is="sh">./list_contains 15 17 17 18</kbd>
<kbd>17</kbd>
1
<kbd is="sh">./list_contains 15 17 17 18</kbd>
<kbd>21</kbd>
0
<kbd is="sh">./list_contains</kbd>
<kbd>42</kbd>
0
</pre>


<h4>Assumptions/Restrictions/Clarifications.</h4>

<b>contains</b> should return a single integer.
<p>
<b>contains</b> should not change the linked list it is given.
Your function should not change the next or data fields of list nodes.
<p>
<b>contains</b> should not use arrays.
<p>
<b>contains</b> should not call malloc.
<p>
<b>contains</b> should not call scanf (or getchar or fgets).
<p>
<b>contains</b> should not print anything. It should not call printf.
<p>
Do not change the supplied <b>main</b> function. It will not be tested or marked.









<div class="alert alert-info">
<strong>New!</strong>
You can run an automated code style checker using the following command:

<pre is="tty">
<kbd is="sh">1511 style list_contains.c</kbd>
</pre>
</div>




<p>
When you think your program is working,
you can use <code>autotest</code>
to run some simple automated tests:

<pre is="tty">
<kbd is="sh">1511 autotest list_contains</kbd>
</pre>
















<p>
When you are finished working on this exercise,

you and your lab partner must both

submit your work by running <code>give</code>:

<pre is="tty">
<kbd is="sh">give cs1511 lab08_list_contains list_contains.c</kbd>
</pre>

<p>

Note, even though this is a pair exercise,
you both must run <code>give</code> from your own account

before <strong>Sunday 08 November 20:00</strong>
to obtain the marks for this lab exercise.






    
        
        
            
            <div class="answer">
                Sample solution for <code>list_contains.c</code>
                
<div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;assert.h&gt;</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">node</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
    <span class="kt">int</span>          <span class="n">data</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">contains</span><span class="p">(</span><span class="kt">int</span> <span class="n">value</span><span class="p">,</span> <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">head</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="nf">strings_to_list</span><span class="p">(</span><span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">strings</span><span class="p">[]);</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">value</span><span class="p">;</span>
    <span class="n">scanf</span><span class="p">(</span><span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">value</span><span class="p">);</span>
    <span class="c1">// create linked list from command line arguments</span>
    <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">head</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// list has elements</span>
        <span class="n">head</span> <span class="o">=</span> <span class="n">strings_to_list</span><span class="p">(</span><span class="n">argc</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
    <span class="p">}</span>

    <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">contains</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">head</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Return 1 if value occurs in linked list, 0 otherwise</span>
<span class="kt">int</span> <span class="nf">contains</span><span class="p">(</span><span class="kt">int</span> <span class="n">value</span><span class="p">,</span> <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">head</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">n</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">n</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">==</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// create linked list from array of strings</span>
<span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="nf">strings_to_list</span><span class="p">(</span><span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">strings</span><span class="p">[])</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">head</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">n</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span> <span class="p">(</span><span class="k">struct</span> <span class="n">node</span><span class="p">));</span>
        <span class="n">assert</span><span class="p">(</span><span class="n">n</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
        <span class="n">n</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
        <span class="n">n</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">atoi</span><span class="p">(</span><span class="n">strings</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="n">head</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
        <span class="n">i</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>   
    <span class="k">return</span> <span class="n">head</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


                
                    Alternative solution for <code>list_contains.c</code>
                    
<div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;assert.h&gt;</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">node</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
    <span class="kt">int</span>          <span class="n">data</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// Return 1 if value occurs in linked list, 0 otherwise</span>
<span class="kt">int</span> <span class="nf">contains</span><span class="p">(</span><span class="kt">int</span> <span class="n">value</span><span class="p">,</span> <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">head</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">head</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">==</span> <span class="n">value</span><span class="p">)</span> <span class="o">||</span> <span class="n">contains</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>

                
            </div>
            
        
    



    </section>

 






    


<section class="exercise with-self">
    <header><h3><small style="font-variant: small-caps; text-transform: lowercase;">Challenge Exercise — individual:
    </small><br />Insert into the nth position in a Linked List</h3></header>
    











<p>
Download list_insert_nth.c <a href="https://cgi.cse.unsw.edu.au/~cs1511/20T3/activities/list_insert_nth/list_insert_nth.c">here</a>, or copy it to your CSE
account using the following command:

<pre is="tty">
<kbd is="sh">cp -n /web/cs1511/20T3/activities/list_insert_nth/list_insert_nth.c .</kbd>
</pre>




<p>
Your task is to add code to this function in <b>list_insert_nth.c</b>:


<div class="highlight"><pre><span></span><span class="c1">// Insert a new node containing value at position n of the linked list.</span>
<span class="c1">// if n == 0, node is inserted at start of list</span>
<span class="c1">// if n &gt;= length of list, node is appended at end of list</span>
<span class="c1">// The head of the new list is returned.</span>
<span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="nf">insert_nth</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">int</span> <span class="n">value</span><span class="p">,</span> <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">head</span><span class="p">)</span> <span class="p">{</span>

    <span class="c1">// PUT YOUR CODE HERE (change the next line!)</span>
    <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

<span class="p">}</span>
</pre></div>





<b>insert_nth</b> is given three arguments, <b>n</b>, <b>value</b> and <b>head</b>.
<b>n</b> is an int.
<b>value</b> is an int.
<b>head</b> is the pointer to the first node in a linked list.
<p>
Add code to <b>insert_nth</b> so that it creates a new list node (using malloc) 
containing value and places it before  position <b>n</b> of the list.
<p>
The elements are counted in the same manner as array elements (zero-based),
so the first element in the list is regarded as at position 0, the second element 
position 1 and so on.
<p>
If there are less than  <code>n</code> elements in the list, the new list node should 
be appended to the end of the list.
<p>
<b>insert_nth</b> should return a pointer to the new list.
<p>
For example if <b>n</b> is 1 and <b>value</b> is <b>12</b> and the linked list contains these 3 elements:
<p>
<pre>
16, 7, 8
</pre>
<p>
<b>insert_nth</b> should return a pointer to a list with these elements:
<p>
<pre>
16, 12, 7, 8
</pre>

<h4>Testing</h4>

<b>list_insert_nth.c</b> also contains a <b>main</b> function which allows you to test your <b>insert_nth</b> function.
<p>
This main function:
<ul>
<li> converts the command-line arguments to a linked list
<li> assigns a pointer to the first node in the linked list to <b>head</b>
<li> reads an integer from standard input and assigns it to <b>n</b>
<li> reads a second integer from standard input and assigns it to <b>value</b>
<li> calls <b>insert_nth(n, value, head)</b>
<li> prints the result.
</ul>
<p>
Do not change this main function.  If you want to change it, you have misread the question.
<p>
Your <b>insert_nth</b> function will be called directly in marking.  The main function is only to let you test your <b>insert_nth</b> function
<p>

<pre is="tty">
<kbd is="sh">dcc list_insert_nth.c -o list_insert_nth</kbd>
<kbd is="sh">./list_insert_nth 16 7 8</kbd>
<kbd>0</kbd>
<kbd>12</kbd>
[12, 16, 7, 8]
<kbd is="sh">./list_insert_nth 16 7 8</kbd>
<kbd>1</kbd>
<kbd>12</kbd>
[16, 12, 7, 8]
<kbd is="sh">./list_insert_nth 16 7 8</kbd>
<kbd>2</kbd>
<kbd>12</kbd>
[16, 7, 12, 8]
<kbd is="sh">./list_insert_nth 16 7 8</kbd>
<kbd>3</kbd>
<kbd>12</kbd>
[16, 7, 8, 12]
<kbd is="sh">./list_insert_nth 16 7 8</kbd>
<kbd>42</kbd>
<kbd>12</kbd>
[16, 7, 8, 12]
<kbd is="sh">./list_insert_nth 42</kbd>
<kbd>0</kbd>
<kbd>16</kbd>
[16, 42]
<kbd is="sh">./list_insert_nth</kbd>
<kbd>0</kbd>
<kbd>2</kbd>
[2]
<kbd is="sh">./list_insert_nth</kbd>
<kbd>10</kbd>
<kbd>2</kbd>
[2]
</pre>




<h4>Assumptions/Restrictions/Clarifications.</h4>

<b>insert_nth</b> should not use arrays.
<p>
<b>insert_nth</b> should not call scanf (or getchar or fgets).
<p>
<b>insert_nth</b> should not print anything. It should not call printf.
<p>
Do not change the supplied <b>main</b> function. It will not be tested or marked.









<div class="alert alert-info">
<strong>New!</strong>
You can run an automated code style checker using the following command:

<pre is="tty">
<kbd is="sh">1511 style list_insert_nth.c</kbd>
</pre>
</div>




<p>
When you think your program is working,
you can use <code>autotest</code>
to run some simple automated tests:

<pre is="tty">
<kbd is="sh">1511 autotest list_insert_nth</kbd>
</pre>
















<p>
When you are finished working on this exercise,

you must

submit your work by running <code>give</code>:

<pre is="tty">
<kbd is="sh">give cs1511 lab08_list_insert_nth list_insert_nth.c</kbd>
</pre>

<p>

You must run <code>give</code>

before <strong>Sunday 08 November 20:00</strong>
to obtain the marks for this lab exercise.


Note that this is an individual exercise,
the work you submit with <code>give</code> must be entirely your own.





    
        
        
            
            <div class="answer">
                Sample solution for <code>list_insert_nth.c</code>
                
<div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;assert.h&gt;</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">node</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
    <span class="kt">int</span>          <span class="n">data</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="nf">insert_nth</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">int</span> <span class="n">value</span><span class="p">,</span> <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">head</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="nf">create_node</span><span class="p">(</span><span class="kt">int</span> <span class="n">data</span><span class="p">,</span> <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">next</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="nf">strings_to_list</span><span class="p">(</span><span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">strings</span><span class="p">[]);</span>
<span class="kt">void</span> <span class="nf">print_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">head</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
    <span class="n">scanf</span><span class="p">(</span><span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">value</span><span class="p">;</span>
    <span class="n">scanf</span><span class="p">(</span><span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">value</span><span class="p">);</span>
    <span class="c1">// create linked list from command line arguments</span>
    <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">head</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// list has elements</span>
        <span class="n">head</span> <span class="o">=</span> <span class="n">strings_to_list</span><span class="p">(</span><span class="n">argc</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
    <span class="p">}</span>

    <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">new_head</span> <span class="o">=</span> <span class="n">insert_nth</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">head</span><span class="p">);</span>
    <span class="n">print_list</span><span class="p">(</span><span class="n">new_head</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="c1">// Insert a new node containing value at position n of the linked list.</span>
<span class="c1">// if n == 0, node is inserted at start of list</span>
<span class="c1">// if n &gt;= length of list, node is appended at end of list</span>
<span class="c1">// The head of the new list is returned.</span>
<span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="nf">insert_nth</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">int</span> <span class="n">value</span><span class="p">,</span> <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">head</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">new_node</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span> <span class="p">(</span><span class="k">struct</span> <span class="n">node</span><span class="p">));</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">new_node</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;out of memory</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">new_node</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>

    <span class="c1">// new node is head of list</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">head</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">new_node</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">new_node</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">new_node</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">new_node</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">head</span><span class="p">;</span>
<span class="p">}</span>



<span class="c1">// create linked list from array of strings</span>
<span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="nf">strings_to_list</span><span class="p">(</span><span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">strings</span><span class="p">[])</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">head</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">n</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span> <span class="p">(</span><span class="k">struct</span> <span class="n">node</span><span class="p">));</span>
        <span class="n">assert</span><span class="p">(</span><span class="n">n</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
        <span class="n">n</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
        <span class="n">n</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">atoi</span><span class="p">(</span><span class="n">strings</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="n">head</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
        <span class="n">i</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>   
    <span class="k">return</span> <span class="n">head</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// print linked list</span>
<span class="kt">void</span> <span class="nf">print_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">head</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;[&quot;</span><span class="p">);</span>    
    <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">n</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">n</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// If you&#39;re getting an error here,</span>
        <span class="c1">// you have returned an invalid list</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">&quot;, &quot;</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


                
                    Alternative solution for <code>list_insert_nth.c</code>
                    
<div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;assert.h&gt;</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">node</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
    <span class="kt">int</span>          <span class="n">data</span><span class="p">;</span>
<span class="p">};</span>


<span class="c1">// Insert a new node containing value at position n of the linked list.</span>
<span class="c1">// if n == 0, node is inserted at start of list</span>
<span class="c1">// if n &gt;= length of list, node is appended at end of list</span>
<span class="c1">// The head of the new list is returned.</span>
<span class="c1">// recursive version</span>
<span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="nf">insert_nth</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">int</span> <span class="n">value</span><span class="p">,</span> <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">head</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">head</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">insert_nth</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">head</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">new_node</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span> <span class="p">(</span><span class="k">struct</span> <span class="n">node</span><span class="p">));</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">new_node</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;out of memory</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">new_node</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
    <span class="n">new_node</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>

    <span class="k">return</span> <span class="n">new_node</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>

                
            </div>
            
        
    



    </section>

 






    


<section class="exercise with-self">
    <header><h3><small style="font-variant: small-caps; text-transform: lowercase;">Challenge Exercise — individual:
    </small><br />Reverse a Linked List</h3></header>
    











<p>
Download list_reverse.c <a href="https://cgi.cse.unsw.edu.au/~cs1511/20T3/activities/list_reverse/list_reverse.c">here</a>, or copy it to your CSE
account using the following command:

<pre is="tty">
<kbd is="sh">cp -n /web/cs1511/20T3/activities/list_reverse/list_reverse.c .</kbd>
</pre>




<p>
Your task is to add code to this function in <b>list_reverse.c</b>:


<div class="highlight"><pre><span></span><span class="c1">//</span>
<span class="c1">// Place the list pointed to by head into reverse order.</span>
<span class="c1">// The head of the list is returned.</span>
<span class="c1">//</span>
<span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="nf">reverse</span><span class="p">(</span><span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">head</span><span class="p">)</span> <span class="p">{</span>

    <span class="c1">// PUT YOUR CODE HERE (change the next line!)</span>
    <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

<span class="p">}</span>
</pre></div>





Note <b>list_reverse.c</b> uses the following familiar data type:

<pre class="program">
struct node {
    struct node *next;
    int          data;
};
</pre>

<b>list_reverse</b> is given  one argument, <b>head</b>, which is the pointer to the first node in the linked list.
<p>
Add code to <b>reverse</b> which rearranges the list to be in reverse order.
<p>
<b>reverse</b> should return a pointer to the new list.
<p>
<b>reverse</b> must rearrange the list by changing the <b>next</b> fields of nodes.
<p>
<b>reverse</b> must not change the <b>data</b> fields of nodes.
<p>
For example if the linked list contains these 8 elements:
<p>
<pre>
16, 7, 8, 12, 13, 19, 21, 12
</pre>
<p>
<b>reverse</b> should return a pointer to a list with these elements:
<p>
<pre>
12, 21, 19, 13, 12, 8, 7, 16
</pre>

<h4>Testing</h4>

<b>list_reverse.c</b> also contains a <b>main</b> function which allows you to test your <b>list_reverse</b> function.
<p>
This main function:
<ul>
<li> converts the command-line arguments to a linked list
<li> assigns a pointer to the first node in the linked list to <b>head</b>
<li> calls <b>reverse(head)</b>
<li> prints the result.
</ul>
<p>
Do not change this main function.  If you want to change it, you have misread the question.
<p>
Your <b>list_reverse</b> function will be called directly in marking.  The main function is only to let you test your <b>list_reverse</b> function
<p>

<pre is="tty">
<kbd is="sh">cp -n /web/cs1511/20T3/activities/list_reverse/list_reverse.c .</kbd>
<kbd is="sh">dcc list_reverse.c -o list_reverse</kbd>
<kbd is="sh">./list_reverse 16 7 8 12 13 19 21 12</kbd>
[12, 21, 19, 13, 12, 8, 7, 16]
<kbd is="sh">./list_reverse 2 4 6 2 4 6</kbd>
[6, 4, 2, 6, 4, 2]
<kbd is="sh">./list_reverse 42</kbd>
[42]
<kbd is="sh">./list_reverse</kbd>
[]
</pre>




<h4>Assumptions/Restrictions/Clarifications.</h4>

<b>list_reverse</b> should not change the data fields of list nodes.
<p>
<b>list_reverse</b> should not use arrays.
<p>
<b>list_reverse</b> should not call malloc.
<p>
<b>list_reverse</b> should not call scanf (or getchar or fgets).
<p>
<b>list_reverse</b> should not print anything. It should not call printf.
<p>
Do not change the supplied <b>main</b> function. It will not be tested or marked.









<div class="alert alert-info">
<strong>New!</strong>
You can run an automated code style checker using the following command:

<pre is="tty">
<kbd is="sh">1511 style list_reverse.c</kbd>
</pre>
</div>




<p>
When you think your program is working,
you can use <code>autotest</code>
to run some simple automated tests:

<pre is="tty">
<kbd is="sh">1511 autotest list_reverse</kbd>
</pre>
















<p>
When you are finished working on this exercise,

you must

submit your work by running <code>give</code>:

<pre is="tty">
<kbd is="sh">give cs1511 lab08_list_reverse list_reverse.c</kbd>
</pre>

<p>

You must run <code>give</code>

before <strong>Sunday 08 November 20:00</strong>
to obtain the marks for this lab exercise.


Note that this is an individual exercise,
the work you submit with <code>give</code> must be entirely your own.





    
        
        
            
            <div class="answer">
                Sample solution for <code>list_reverse.c</code>
                
<div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;assert.h&gt;</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">node</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
    <span class="kt">int</span>          <span class="n">data</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="nf">reverse</span><span class="p">(</span><span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">head</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="nf">strings_to_list</span><span class="p">(</span><span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">strings</span><span class="p">[]);</span>
<span class="kt">void</span> <span class="nf">print_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">head</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="c1">// create linked list from command line arguments</span>
    <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">head</span> <span class="o">=</span> <span class="n">strings_to_list</span><span class="p">(</span><span class="n">argc</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>

    <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">new_head</span> <span class="o">=</span> <span class="n">reverse</span><span class="p">(</span><span class="n">head</span><span class="p">);</span>
    <span class="n">print_list</span><span class="p">(</span><span class="n">new_head</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Place the list into reverse order.</span>
<span class="c1">// The head of the list is returned.</span>

<span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="nf">reverse</span><span class="p">(</span><span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">head</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">head</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">previous</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">x</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">x</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="n">x</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">previous</span><span class="p">;</span>
        <span class="n">previous</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">y</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">previous</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// create linked list from array of strings</span>
<span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="nf">strings_to_list</span><span class="p">(</span><span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">strings</span><span class="p">[])</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">head</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">n</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span> <span class="p">(</span><span class="k">struct</span> <span class="n">node</span><span class="p">));</span>
        <span class="n">assert</span><span class="p">(</span><span class="n">n</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
        <span class="n">n</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
        <span class="n">n</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">atoi</span><span class="p">(</span><span class="n">strings</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="n">head</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">head</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// print linked list</span>
<span class="kt">void</span> <span class="nf">print_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">head</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;[&quot;</span><span class="p">);</span>

    <span class="k">for</span> <span class="p">(</span><span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">n</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span> <span class="n">n</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="n">n</span> <span class="o">=</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// If you&#39;re getting an error here,</span>
        <span class="c1">// you have returned an invalid list</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">&quot;, &quot;</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


                
                    Alternative solution for <code>list_reverse.c</code>
                    
<div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;assert.h&gt;</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">node</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
    <span class="kt">int</span>          <span class="n">data</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// Place the list into reverse order.</span>
<span class="c1">// The head of the list is returned.</span>

<span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="nf">reverse</span><span class="p">(</span><span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">head</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// lists of 0 or 1 node don&#39;t need to be changed</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">head</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">head</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">//reverse rest of list</span>
    <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">new_head</span> <span class="o">=</span> <span class="n">reverse</span><span class="p">(</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">);</span>

    <span class="c1">// head-&gt;next will be the last element in the reversed rest of list</span>
    <span class="c1">// append head to it</span>
    <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
    <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

    <span class="k">return</span> <span class="n">new_head</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>

                
            </div>
            
        
    



    </section>





<section class="exercise ">
    <header><h3>Submission</h3></header>
    


When you are finished each exercises make sure you submit your work by running <code>give</code>.
<p>
You can run <code>give</code> multiple times.
Only your last submission will be marked.
<p>
Don't submit any exercises you haven't attempted.
<p>
If you are working at home, you may find it more convenient
to upload your work via
<a href="https://cgi.cse.unsw.edu.au/~give/Student/give.php">give's web interface</a>.
<p>
Remember you have until

<b>Week 8 Sunday 20:00</b>

to submit your work.
<p>
You cannot obtain marks by e-mailing your code to tutors or lecturers.
<p>
You check the files you have submitted <a href="https://cgi.cse.unsw.edu.au/~cs1511/20T3/student/">here</a>.
<p>
Automarking will be run by the lecturer several days after the submission deadline,
using test cases different to those <code>autotest</code> runs for you.
(Hint: do your own testing as well as running <code>autotest</code>.)
<p>
After automarking is run by the lecturer
you can <a href="https://cgi.cse.unsw.edu.au/~cs1511/20T3/student/">view your results here</a>.
The resulting mark will also be available
<a href="https://cgi.cse.unsw.edu.au/~give/Student/sturec.php">via give's web interface</a>.

<h4>Lab Marks</h4>
<p>
When all components of a lab  are automarked you should be able to view the
the marks <a href="https://cgi.cse.unsw.edu.au/~give/Student/sturec.php">via give's web interface</a>
or by running this command on a CSE machine:

<pre is="tty">
<kbd is="sh">1511 classrun -sturec</kbd>
</pre>










    </section>


</div>



</main>

<footer class="mt-3 pt-3 bg-dark text-center no-print">
<p class="text-muted">
<strong>COMP1511 20T3: Programming Fundamentals</strong>
is brought to you by <br />
the <a href="https://www.cse.unsw.edu.au/">School of Computer Science and Engineering</a><br />
at the <a href="https://www.unsw.edu.au/">University of New South Wales</a>, Sydney.<br />
For all enquiries, please email the class account at
<a href="mailto:@cse.unsw.edu.au">cs1511@cse.unsw.edu.au</a><br />

<small>CRICOS Provider 00098G</small>
</p>


</footer>

</body>
</html>